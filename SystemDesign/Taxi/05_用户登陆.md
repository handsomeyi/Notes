# 验证码校验

## 流程图

- 客户端申请验证码

- 生成验证码, 用**redis设置过期时间**

- 第三方sms服务发送验证码(阿里的贵, 华信的便宜)

![image-20211203195143888](https://i.loli.net/2021/12/03/h6Y41zNJgRK7Gxq.png)

 





api-passenger: 发送验证码			url：sms/verify-code/send

```java
参数：
{
 "phoneNumber":"13498767890a"
}

返回参数：
{
"code":100000,
"message":"success",
"data": T
}
```

service-verification-code：生成验证码			url:verify-code/generate/{身份 乘客，司机}/（手机号）13454567897



service-sms：发送短信（通用），腾讯短信通，阿里短信服务，华信
url：/send/sms-template

```java
参数：
{
 "receivers":["13465434567"，。。。。],
      "data":[
         {
          "id": "SMS_144145499",
          "templateMap": {
          "code": "018900"
          }
         }
      ]
}
```

短信模板id，
短信模板: 其中：

模板内容为：您正在申请手机注册，验证码为：${code}，5分钟内有效！。
模板变量为：${code}。

```java
//先存redis再发短信

// 81B*10 1024 1K 10*1024  1M-----------所以直接放内存里 没必要放redis
// 如果50M+ 就再放redis挺好

guava 缓存
    组件?
@cache缓存 
    把参数当成key,返回结果当成value存在缓存里
```

**==常用的不变的东西放缓存==**

**缓存的作用 : 利用内存, 减少IO**



## 提升QPS

**提高并发数**

1. 能用多线程用多线程。线程数=cpu可用核数 / (1-阻塞系数)  阻塞系数: io↑=1 计算↑=0

   比如下载: 

   - IO高: 可以启超多线程
   - 计算高: 就看cpu核数的瓶颈了,所以趋近于0

2. 增加各种连接数：tomcat mysql redis等等。

3. 服务==无状态==，便于横向扩展。扩机器。

4. 让服务能力对等。（serviceUrl：打乱顺序）------ 不要让一个eureka负载大, 而其他的没事干

## 减少相应时间

1. 异步（最终一致性，不需要及时返回的信息），流量削峰(ming MQ)
2. 缓存。（减少db读取，减少磁盘io，读多，写少）
3. 数据库优化。
4. 多的数据，分批次返回。
5. 微服务中 减少 调用链remotecall
6. 长连接 降低并发数 。不要 轮询（）   SSE ???

## 提示

生产环境中不能用快照

<version>**0.0.1**-SNAPSHOT</version>

---

常用的, 不变的 ==> 用缓存，不要每次都去db

系统主要是IO瓶颈：网络，磁盘IO
减少IO就能提升性能

---

# 登陆

## JWT

token存在本地服务器redis中  可以实现T用户下线



## 鉴权

**鉴权** (authentication)是指验证用户是否拥有访问系统的权利

zuul 里面的 鉴权filter

![image-20211205212149211](https://s2.loli.net/2021/12/05/fj31bc9LtGzymRH.png)

```java
@Component
public class AuthFilter extends ZuulFilter {
    @Autowired
	private RedisTemplate<String, String> redisTemplate;
    //......
    	@Override
	public Object run() throws ZuulException {
		System.out.println("auth 拦截");
		//获取上下文（重要，贯穿 所有filter，包含所有参数）
		RequestContext requestContext = RequestContext.getCurrentContext();
		HttpServletRequest request = requestContext.getRequest();
//      parseBody(request);
		String token = request.getHeader("Authorization");
		if (StringUtils.isNotBlank(token)){
            JwtInfo tokenJwtInfo = JwtUtil.parseToken(token);//解析token
            if(null != tokenJwtInfo) {
                String tokenUserId = tokenJwtInfo.getSubject();
                Long tokenIssueDate = tokenJwtInfo.getIssueDate();
				requestContext.set("userId",tokenUserId);
				return null;
            }
        }
        // 不往下走，还走剩下的过滤器，但是不向后面的服务转发。
        requestContext.setSendZuulResponse(false);
        requestContext.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());
        requestContext.setResponseBody("auth fail");
//      requestContext.set("ifContinue",false);
		return null;
	}
}
```









### 问题:

客户端和服务端 时间不对等 需要同步 就是**预约功能**......

bigdecimal

long

分





















