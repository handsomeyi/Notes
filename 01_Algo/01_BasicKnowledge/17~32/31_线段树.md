# 线段树

参考这位巨佬的理解https://www.cnblogs.com/AKMer/p/9946944.html
树状数组和线段树都是用于维护数列信息的数据结构, 支持单点/区间修改, 单点/区间询问信息.
以增加权值与询问区间权值和为例, 其余的信息需要维护也都类似, 时间复杂度均为O(logn).

区间的修改., 更新, 查询一些东西, 怎么样才能比较快
可以叫 区间修改树更准确, 最早是解决线段重合问题
物理结构不是树, 用的时候跟树也关系不大
只是在逻辑概念上对应成了一棵树



1. **一种支持范围整体修改和范围整体查询的数据结构**

2. **解决的问题范畴：**
   **大范围信息可以==只由左、右两侧信息简单加工出==，**
   **而不必遍历左右两个子范围的具体状况**
   **比如: ==最大值, 最小值, 累加和==**

区间范围上要统一增加一个值,或者update一个值,
需要查询的一个值满足如下条件才能用线段树:
**父范围的信息可以由左树右树的信息直接加工出来, 不需要具体调研左树和右树状况**



比如说找区间众数, 不能由左右子树加工, 只能全体整理信息



还是**分而治之**的思想



# 例题



给定一个数组arr，用户希望你实现如下三个方法
1）void add(int L, int R, int V) :  让数组arr[L…R]上每个数都加上V
2）void update(int L, int R, int V) :  让数组arr[L…R]上每个数都变成V
3）int sum(int L, int R) :让返回arr[L…R]这个范围整体的累加和
怎么让这三个方法，时间复杂度都是O(logN)





https://leetcode-cn.com/problems/falling-squares/

想象一下标准的俄罗斯方块游戏，X轴是积木最终下落到底的轴线  
下面是这个游戏的简化版：  
1）只会下落正方形积木  
2）[a,b] -> 代表一个边长为b的正方形积木，积木左边缘沿着X = a这条线从上方掉落  
3）认为整个X轴都可能接住积木，也就是说简化版游戏是没有整体的左右边界的  
4）没有整体的左右边界，所以简化版游戏不会消除积木，因为不会有哪一层被填满。  

给定一个N* 2的二维数组matrix，可以代表N个积木依次掉落，返回每一次掉落之后的最大高度

