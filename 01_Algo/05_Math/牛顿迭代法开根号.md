# 牛顿迭代法开根号


---

本质就是[[泰勒公式]]的展开, 因为是二阶函数, 三阶及以上导数为零. 可以很方便的推导得到求解公式.

![](https://img-blog.csdnimg.cn/20181217221748469.png)

设 $r$ 是$f(x) = 0$ 的根，选取 $x_0$ 作为$r$ 的初始近似值，过点 $(x_0, f(x_0))$ 做曲线 $y = f(x)$的切线$L$ ，$L: y = f(x_0) + f'(x_0)(x - x_0)$ ，则$L$与$x$轴交点的横坐标 $x_1 = x_0 - \frac{f(x_0)}{f'(x_1)}$，称$x_1$为$r$ 的一次近似值。过点$(x_1, f(x_1))$ 做曲线 $y = f(x)$的切线，并求该切线与$x$轴交点的横坐标$x_2 = x_1 - \frac{f(x_1)}{f'(x_1)}$ ，称$x_2$ 为$r$的二次近似值。重复以上过程，得 $r$ 的近似值序列，其中，$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$ 称为 r 的 $n+1$次近似值，上式称为牛顿迭代公式。

用 $y_0$ 表示待求出平方根的那个整数。显然，$y_0$ 的平方根就是函数   
$y =f(x) = x^2 - y_0$   的零点。

>零点，对于函数 y=f(x) ，使 f(x)=0 的实数 x 叫做函数 y=f(x) 的零点，即零点不是点。这样，函数 y=f(x) 的零点就是方程 f(x)=0 的实数根，也就是函数 y=f(x) 的图象与 x 轴的交点的横坐标。


由 $x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$ 带入 $f(x) = x^2 - y_0$, 有:
$x_{n+1} = x_n - \frac{x_n^2 - y_0}{2x_n}$ ==>  

$x_{n+1} = \frac{x_n + y_0/x_n}{2}$

$y_0$是待求平方根的数

---
https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/

用 C 表示待求出平方根的那个整数。显然，C 的平方根就是函数   
$y =f(x) = x^2 - C$   
的零点。牛顿迭代法的本质是借助泰勒级数，从初始值开始快速向零点逼近。
我们任取一个 $x_0$作为初始值，在每一步的迭代中，我们找到函数图像上的点$(x_i, f(x_i))$, 过该点作一条斜率为该点导数 $f'(x_i)$的直线，与横轴的交点记为 $x_{i+1}$。$x_{i+1}$相较于$x_i$而言距离零点更近。在经过多次迭代后，我们就可以得到一个距离零点非常接近的交点。下图给出了从 $x_0$开始迭代两次，得到 $x_1$和 $x_2$的过程。

选择$x_0 = C$ 作为初始值, 每次迭代均有 $x_{i+1} < x_i$, 零点 $\sqrt{C}$在其左侧，所以我们一定会迭代到这个零点。

![[Pasted image 20210115233923.png|600]]

---

首先随便猜一个近似值x，然后不断令x等于x和a/x的平均数，迭代个六七次后x的值就已经相当精确了。  
    例如，我想求根号2等于多少。假如我猜测的结果为4，虽然错的离谱，但你可以看到使用牛顿迭代法后这个值很快就趋近于根号2了：

(       4  + 2/   4     ) / 2 = 2.25  
(    2.25  + 2/   2.25  ) / 2 = 1.56944..  
( 1.56944..+ 2/1.56944..) / 2 = 1.42189..  
( 1.42189..+ 2/1.42189..) / 2 = 1.41423..  
….

这种算法的原理很简单，我们仅仅是不断用(x,f(x))的切线来逼近方程x^2-a=0的根。根号a实际上就是x^2-a=0的一个正实根，这个函数的导数是2x。也就是说，函数上任一点(x,f(x))处的切线斜率是2x。那么，x-f(x)/(2x)就是一个比x更接近的近似值。代入f(x)=x^2-a得到x-(x^2-a)/(2x)，也就是(x+a/x)/2。

![[Pasted image 20210115234729.png]]



```java
public static int mySqrt1(int x) {
    int r = x;
    while ( r > x/r) {
        r = (r + x/r) /2;
    }
    return r;
}

public static double mySqrtDouble1(int x) {
    if (x == 0) {
        return 0;
    }
    double x0 = x;
    while (Math.abs(x0 - x / x0) > 1e-9) {
        x0 = 0.5 * (x0 + x / x0);
    }
    return x0;
}

public static double mySqrtDouble1(int x) {
    if (x == 0) {
        return 0;
    }

    double C = x, x0 = x;
    while (true) {
        double xi = 0.5 * (x0 + C / x0);
        if (Math.abs(x0 - xi) < 1e-9) {
            break;
        }
        x0 = xi;
    }
    return x0;
}


```