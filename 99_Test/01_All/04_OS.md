# 1. 什么是操作系统

管理协调硬件与软件资源的系统软件()

# 2. 系统调用

​	用户态切换到内核态的几种方式

# 3. 进程和线程的区别

参考: https://zhuanlan.zhihu.com/p/433518016

- 功能: 进程是操作系统资源分配的基本单位, 而线程是任务调度和执行的基本单位
- 开销: 
  - 每个进程都有独立的内存空间, 存放代码和数据段等, 程序之间的切换会有较大的开销;
  - 线程可以看做轻量级的进程, 共享内存空间, 每个线程都有自己**==独立的运行栈和程序计数器==**, 线程之间切换的开销小. 
- 运行环境: 在操作系统中能同时运行多个进程;而在同一个进程(程序)中有多个线程同时执行(通过CPU调度, 在每个时间片中只有一个线程执行)
- 创建过程: 
  - 在创建新进程的时候, 会将父进程的所有五大数据结构复制新的, 形成自己新的内存空间数据, 
  - 而在创建新线程的时候, 则是引用进程的五大数据结构数据, 但是线程会有自己的私有数据, 栈空间. 
- 进程和线程其实在cpu看来都是task_struct结构的一个封装, 执行不同task即可, 而且在cpu看来就是在执行这些task时候遵循对应的调度策略以及上下文资源切换定义, 包括寄存器地址切换, 内核栈切换. 所以对于cpu而言, 进程和线程是没有区别的. 

**在Linux操作系统底层**

fork => 新的进程(使用不同内存空间) => 进程

clone => 新的"进程"(与原进程同一个内存空间) => 线程

![preview](https://s2.loli.net/2022/04/13/jvaYSxNUKiMQwd6.jpg)

**也许你会问, tgid是什么?** 
当程序开始运行时, 只有一个主线程, 这个主线程的tgid就等于pid。而当其他线程被创建的时候, 就继承了主线程的tgid。这样, 内核就可以通过tgid知道某个task属于哪个线程组, 也就知道属于哪个进程了。当我们用ps命令或者getpid()等接口查询进程id时, 内核返回给我们的也正是这个tgid。
所以什么是线程组？其实就是进程。

在Linux操作系统层面, 线程其实只是特殊的进程, 最特殊之处在于跟其他“线程进程“共享内存(包括代码段, 数据段等, 但不共享栈)。

# 4. 线程切换开销为啥比进程小

1. 线程切换不需要更换页表, 而进程切换需要。页表切换缓存失效, 性能低(虚拟内存, 页表)
2. 进程切换需要切换上**==下文环境比线程上下文环境大==**, 保存现场, 切换, 到恢复现场更耗时。

**进程上下文环境?** (同时阅读几本书, 看书来回切换就要保存当前看到第几页了.)
程序计数器, 通用寄存器, 数据, 用户栈, 页表, pcb等

**中断处理, 多任务处理, 内核/用户态切换**  => 上下文切换情况

- **在中断处理中**, 其他程序”打断”了当前正在运行的程序。当CPU接收到中断请求时, 会在正在运行的程序和发起中断请求的程序之间进行一次上下文切换。
- **在多任务处理中**, CPU会在不同程序之间来回切换, 每个程序都有相应的处理时间片, CPU在两个时间片的间隔中进行上下文切换。
- **内核/用户态切换**, 进行系统调用时, CPU寄存器里原来用户态的指令位置需要先保存起来。接着, 为了执行内核态代码, CPU寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。而系统调用结束后, CPU寄存器需要恢复原来保存的用户态, 然后再切换到用户空间, 继续运行进程, 所以一次系统调用的过程, 其实是发生了两次CPU上下文切换。

# 4. 协程?

用户态 => 完全由用户控制 => 比线程更轻量级 => 协程的切换和调度不需要经过内核 => 性能高

# 5. 进程5种状态

- 新建态(创建一个进程)
- 就绪态(已经获取到资源, 准备好了, 进入就绪队列, 一旦获得时间片可以立即执行)
- 运行态(获取到了时间片, 执行程序)
- 阻塞态(运行过程中等待获取其他资源, I/O请求等)
- 终止态(进程被杀死了)

**java中线程6种状态**
new, runnable(就绪+运行), blocked(阻塞于锁), waiting, timed_waiting, terminated

# 6. 内存管理

## 内存管理的发展历程

DOS时代 - 同一时间只能有一个进程在运行(也有一些特殊算法可以支持多进程)

windows9x - 多个进程装入内存 1: 内存不够用 2: 互相打扰

为了解决这两个问题, 诞生了现在的内存管理系统: 虚拟地址 分页装入 软硬件结合寻址

![image-20220325233808747](https://s2.loli.net/2022/04/13/IE5wHZ6kr8QAvtj.png)

1. 分页(内存不够用), 内存中分成固定大小的页框(4K), 把程序(硬盘上)分成4K大小的块, 用到哪一块, 加载那一块, 加载的过程中, 如果内存已经满了, 会把最不常用的一块放到swap分区,  把最新的一块加载进来, 这个就是著名的LRU算法

   1. LRU算法 LeetCode146题, 头条要求手撕, 阿里去年也要求手撕
   2. Least Recently Used 最不常用
   3. 哈希表(保证 查找操作O(1)) + 链表 (保证 排序操作和新增操作 O(1)))
   4. 双向链表 (保证 左边指针 指向右边块)
2. 虚拟内存(解决相互打扰问题)

   1. DOS Win31 ... 互相干掉
   2. 为了保证互不影响 - 让进程工作在虚拟空间, 程序中用到的空间地址不再是直接的物理地址, 而是虚拟的地址, 这样, A进程永远不可能访问到B进程的空间
   3. 虚拟空间多大呢？寻址空间 - 64位系统 2 ^ 64, 比物理空间大很多 , 单位是byte
   4. 站在虚拟的角度, 进程是独享整个系统 + CPU
   5. 内存映射: 偏移量 + 段的基地址 = 线性地址 (虚拟空间)
   6. 线性地址通过 OS + MMU(硬件 Memory Management Unit)
3. 缺页中断(不是很重要): 

   1. 需要用到页面内存中没有, 产生缺页异常(中断), 由内核处理并加载


## 虚拟内存

- **==隔离应用程序, 满足==**

  每个程序都认为自己有连续可用的内存

- **==突破物理内存限制==**

  应用程序不需要考虑物理内存是否够用, 是否能够分配等底层问题

- **==安全==**

  保护物理内存, 不被恶意程序访问, 以前没有虚拟内存, 导致各种病毒bug操作内存. 

  

  虚拟内存实现了进程隔离 => 相当于每个进程独享了一个内核, 用户栈...

  ![image-20220325235115963](https://s2.loli.net/2022/04/13/hSXZMGLKnyc4fT8.png)

内存管理模型

![image-20220326000702529](https://s2.loli.net/2022/04/13/EgrTiYw7PsaSy2v.png)



![image-20220326000738754](https://s2.loli.net/2022/04/13/hfjpyFYZLWz6Qc9.png)

## 几种内存管理机制

**块式管理**: 将内存分为一个个块, 一个块包含一个进程
**页式管理**: 将内存空间分为一个个大小相等的分区, 每个分区就是一个页框, 然后将进程的逻辑地址分页存储在页框中, 通过⻚表对应逻辑地址和物理地址
**段式管理**: 内存被划分为若干个段, 按段存储
**段页式管理**: 把主存先分成若干段, 每个段又分成若干页。

页表: 存储页面与页框对于关系, 通过页表对应逻辑地址与物理地址。

# 7. 孤儿进程与僵尸进程

- 僵尸进程(危害): 

  子进程退出, 父进程没有调用wait()/waitpid()获取子进程终止状态, 子进程保留的PCB信息(包括pid)得不到释放, 占用进程号, 浪费资源, 等进程号耗尽便无法产生新进程。

- 孤儿进程(无害): 

  父进程退出, 子进程还在运行, 这些进程便称为孤儿进程。孤儿进程将被init进程(进程号为1)收养, 并由init进程完成进程收集工作。

# 8. 进程间通信与线程间通信

### 进程间通信

进程间通信主要包括: 管道, 命名管道, 信号, 消息队列, 共享内存, 内存映射, 信号量, Socket

1. **管道**

   管道也叫无名(匿名)管道, 它是是 UNIX 系统 IPC(进程间通信)的最古老形式, 所有的 UNIX 系统都支持这种通信机制. 管道本质其实是内核中维护的一块内存缓冲区, Linux 系统中通过 pipe() 函数创建管道, 会生成两个文件描述符, 分别对应管道的读端和写端. 无名管道只能用于具有亲缘关系的进程间的通信. 

2. **命名管道**

   匿名管道, 由于没有名字, 只能用于亲缘关系的进程间通信. 为了克服这个缺点, 提出了有名管道(FIFO), 也叫命名管道, FIFO文件. 有名管道(FIFO)不同于匿名管道之处在于它提供了一个路径名与之关联, 以 FIFO 的文件形式存在于文件系统中, 并且其打开方式与打开一个普通文件是一样的, 这样即使与 FIFO 的创建进程不存在亲缘关系的进程, 只要可以访问该路径, 就能够彼此通过 FIFO 相互通信, 因此, 通过 FIFO 不相关的进程也能交换数据. 

3. **信号**

   信号是 Linux 进程间通信的最古老的方式之一, **是事件发生时对进程的通知机制**, 有时也称之为**软件中断**, 它是在软件层次上对中断机制的一种模拟, 是一种异步通信的方式. 信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断, 转而处理某一个突发事件. 

4. **消息队列**

   消息队列就是一个消息的链表, 可以把消息看作一个记录, 具有特定的格式以及特定的优先级, 对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息, 对消息队列有读权限的进程则可以从消息队列中读走消息, 消息队列是随内核持续的. 

5. **共享内存**

   **共享内存允许两个或者多个进程共享物理内存的同一块区域**(通常被称为段). 由于一个共享内存段会称为一个进程用户空间的一部分, 因此这种 IPC 机制无需内核介入. 所有需要做的就是让一个进程将数据复制进共享内存中, 并且这部分数据会对其他所有共享同一个段的进程可用. 与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比, 这种 IPC 技术的速度更快. 

6. **内存映射**

   内存映射(Memory-mapped I/O)是将磁盘文件的数据映射到内存, 用户通过修改内存就能修改磁盘文件. 

7. **信号量**

   信号量主要用来解决进程和线程间并发执行时的同步问题, 进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动. 对信号量的操作分为 P 操作和 V 操作, 

   **P 操作是将信号量的值减 1**, 

   **V 操作是将信号量的值加 1**. 当信号量的值小于等于 0 之后, 再进行 P 操作时, 当前进程或线程会被阻塞, 直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时. 

8. **Socket**

   套接字(Socket), 就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象. 一个套接字就是网络上进程通信的一端, 提供了应用层进程利用网络协议交换数据的机制. Socket 一般用于网络中不同主机上的进程之间的通信. 

### 线程间通信

1. **共享变量** => valatile
2. **互斥量(Mutex)** => 互斥对象机制(synchronized, lock)
3. **事件(Event)** => wait() notifyAll()
4. **信号量** => 允许多个线程同时访问同⼀资源, 但是要控制最大线程数. 
5. CountDownLatch 设置初始值, 线程运行时调用countDownLatch.countDown()使值减一, 被通知线程countDownLatch.await()
6. 使用Condition的await()和singnalAll()方法

# 9. 堆栈区别

申请方式: 栈系统自动申请, 堆需手动申请 c语言malloc(), java new Object();
stack系统分配速度快, 堆慢, 容易内部碎片;
栈地址空间连续, 堆是不连续的(链表存储空闲内存地址);
内容不一样, 大下限制(栈预先设定好的, 堆取决有效虚拟内存)

# 10. 什么情况下Java程序会产生死锁？如何定位. 恢复？

- 死锁原因: 
  两个或多个任务以不合理的顺序相互竞争资源造成相互等待, 无限期阻塞
  例如: 线程A持锁a, 获取锁b;线程B持锁b, 获取锁a, 就会死锁

- 死锁检测: 

  - jps, ps, 任务管理器获取进程ID
  - jstack pid获取进程中**==线程堆栈信息==**(区分线程状态 -> 查看等待目标 -> 对比 Monitor 等持有状态)
  - jconsole, Jvisualvm排查死锁问题(java监视管理平台)

- 死锁解决: 

  - **==打破造成死锁条件==**(互斥, 不可剥夺, 请求与保持, 循环等待)

    1. **不可剥夺**: 一个进程不能获得所需要的全部资源时便处于等待状态, 等待期间他占有的资源将 被隐式的释放重新加入到系统的资源列表中, 可以被其他的进程使用, 而等待的进 程只有重新获得自己原有的资源以及新申请的资源才可以重新启动, 执行

    2. **请求与保持**: 第一种方法**静态分配**即每个进程在开始执行时就申请他所需要的全部资源
       第二种是**动态分配**即每个进程在申请所需要的资源时他本身不占用系统资源

    3. **循环等待**: 采用资源有序分配其基本思想是将系统中的所有资源顺序编号, 将紧缺的, 稀少的 采用较大的编号, 在申请资源时必须按照编号的顺序进行, 一个进程只有获得较小编号的进程才能申请较大编号的进程。

  - **按顺序获取锁**, 使用超时锁, 不要同时获取多把锁

# 12. 分页机制与分段机制异同

- 共同点 : 
  - 分⻚机制和分段机制都是为了提⾼内存利⽤率, 减少内存碎⽚。
  - ⻚和段都是离散存储的, 所以两者都是离散分配内存的⽅式。但是, 每个⻚和段中的内存是连续的。
- 区别 (段: 地址空间二维, 产生外部碎片, 大小不固定, 对用户可见, 更容易信息共享与保护)
  - 分页对用户不可见, 分段对用户可见
  - 分页地址空间一维, 分段地址空间二维
  - 分段更容易实现信息的共享与保护
  - 分段会产生外部碎片;分页内存利用率更高, 不会产生外部碎片
  - 页的大小是固定的, 由操作系统决定;而段的大小不固定, 取决于我们当前运⾏的程序

# 13. select. poll. epoll(都是系统调用)

### IO模型

https://zhuanlan.zhihu.com/p/115912936 5种IO模型

https://cloud.tencent.com/developer/article/1862671 epoll 为什么用红黑树？

![img](https://s2.loli.net/2022/04/13/osatUQx4HDeCwMh.jpg)

同步阻塞IO => 同步非阻塞IO => 加入IO多路复用器 => 加入epoll机制(信号驱动) => 异步IO

**同步阻塞IO**

![image-20220323151015356](https://s2.loli.net/2022/04/13/9Fv1mtwuoXHhYsp.png)

服务器应用B线程调用revcfrom时, 从kernel缓冲区读取fd会一直阻塞, 直到数据包到达缓冲区或报错.

所以是一个接着一个轮流读取内核中fd. => 慢

**同步非阻塞IO** 



![image-20220323151038146](https://s2.loli.net/2022/04/13/aon4YZxLJHTMNvC.png)

应用B线程从kernel读取fd时, 会遍历用户空间的fd=>然后来内核缓冲区询问是否到达

轮询一次发生在用户空间 => 查询一次就要调一次系统调用内核态用户态来回切换 => CPU保护恢复现场 

所以开销大, 应该尽量把

**加入IO多路复用器** **==内核增加系统调用select==**

![image-20220323152436096](https://s2.loli.net/2022/04/13/8QDsTqmxuXW7BRo.png) 

![image-20220323151135860](https://s2.loli.net/2022/04/13/UEcrIYzLPGX5Zlh.png)

Linux内核新增select系统调用 => 用户进程B 把你要监控的1000个fd传给内核 => 一次

kernel自己监控, 当数据到达 => 返回ready的fd => 然后B再调用**read系统调用** =>一次

所以减少了内核态用户态切换 => 提高CPU利用效率



**加入epoll机制(信号驱动)** => 因为select拷贝数据来去开销 又想优化 => **==共享空间==**

内核又新增了**==mmap系统调用==** => 内核态与用户态的共享空间

![image-20220323153844543](https://s2.loli.net/2022/04/13/SPpTRlK4ZHV27GO.png)

![image-20220323153614872](https://s2.loli.net/2022/04/13/bDOCJdck6Sl3e8B.png)

详细理解 内核态与用户态的共享空间**如何创建(epoll_create) 如何使用(epoll_wait)** 

然后数据来了  => 软中断 => 从fd buffer拷贝数据到红黑树

![image-20220323160701976](https://s2.loli.net/2022/04/13/eJNAnyOw5REMYzc.png)



###  **==在 Linux 的设计中有三种典型的 I/O 多路复用模型 select, poll, epoll==** 

 **select 是一个主动模型, 需要线程自己通过一个集合存放所有的 Socket, 然后发生 I/O 变化的时候遍历**. 在 select 模型下, 操作系统不知道哪个线程应该响应哪个事件, 而是由线程自己去操作系统看有没有发生网络 I/O 事件, 然后再遍历自己管理的所有 Socket, 看看这些 Socket 有没有发生变化.  

 **poll 提供了更优质的编程接口, 但是本质和 select 模型相同**. 因此千级并发以下的 I/O, 你可以考虑 select 和 poll, 但是如果出现更大的并发量, 就需要用 epoll 模型.  

 **epoll 模型在操作系统内核中提供了一个中间数据结构, 这个中间数据结构会提供事件监听注册, 以及快速判断消息关联到哪个线程的能力(红黑树实现)**. 因此在高并发 I/O 下, 可以考虑 epoll 模型, 它的速度更快, 开销更小. 

**AIO暂时Linux没实现**

**基本原理概叙**: 

- **select**: 将文件描述符(fds)收集给内核, 内核发现有数据到来, select返回, 并将有数据的fd值为1。用户空间中, 由于SELECT 没有返回哪些 fd 有数据到来, 用户态需要遍历得到置位的fd读取数据并处理, O(n)时间复杂度。
  ○缺点: fd有大小限制, bitmap数据结构, 1024；需要一次用户态内核态切换, 处理需要线性遍历fd
  ○优点: 由内核态判断fds有无数据到来, 只需要一次用户内核切换, 不然每次都要切
- **poll**: 原理和select近似, 只是poll采用结构体表示fd(int fd-指定给fd, int event-监听的某个事件, int revent)-结构体+链表
- **epoll**: 结构体+链表, 没有置位操作, 用户内核态共享内存, 返回有数据到来的fd, 不用遍历

# 14. 中段是什么

硬件 => 操作系统内核 通信机制 (例如网卡接受到socket来的数据 => 中断通知内核的红黑树, 加入数据)

**==软中断==**(80中断) ==>  系统调用

int 0x80 或者 sysenter原语



网卡来数据 => jvm read() => c库read() => 内核空间 => system_call() => sys_read()

# 14. 进程调度算法

先来先服务、短作业优先、时间片轮转、多级反馈队列、优先级调度

非抢占式 => 除非进程主动让出cpu（yielding），否则将一直运行
抢占式 => 由进程调度器强制开始或暂停（抢占）某一进程的执行

Linux2.5的时候 => 采用Unix O(1)调度策略(**==每个进程固定10ms==**) => 偏向服务器 => 对交互不友好
Linux2.6的时候 => 采用CFS完全公平调度算法(Completely Fair Scheduler)
CFS => 按照执行时间合理分配时间片, **==按需分配==**

# 15. 页面置换算法

FIFO(First In First Out)页面置换算法(先进先出页面置换算法)
LRU (Least Recently Used）页面置换算法(最近最久未使用页面置换算法）
OPT 页面置换算法(最佳页面置换算法）未来长时间不使用的或永久不使用的，理想的，无法实现的，无法确定页面访问时间
时钟(CLOCK)置换算法: 
●当内存中无对应数据，访问位为 0 即可置换，再变换访问位为 1，然后指针下移。
●当内存中无对应数据，访问位为 1 不置换，再变换访问位为 0，然后指针下移。
●当内存中有对应数据时，访问位变换，指针下移。

# 18. Linux常用命令

pwd: 显示当前所在位置
kill -9  pid : 杀死进程(-9 表示强制终止）
kill -2 pid: 保存相关数据再退出
tar -xvf : 解压
wget : 是从远程下载的工具
top: 查看占用cpu高的进程
df -h: 查看磁盘空间

网络相关: 
netstat -ntl
netstat -naptul | grep 端口

进程: 
ps -ef | grep xxx
telnet IP地址 端口: 判断主机是否开启了某个端口
ping : 查看与某台机器的连接情况。TTL: 生存时间。数据报被路由器丢弃之前允许通过的网段数量
linux如何查看端口被哪个进程占用的方法: 
1、lsof -i:端口号
2、netstat -tunlp|grep 端口号

```bash
# 查找指定进程
ps -ef | grep [进程关键字]

netstat -ntl  # [t:tcp u:udp l:处于监听状态连接 n:以IP地址显示]
# 查找某个端口
netstat -ntl | grep 端口

# 查看一个进程所占内存
ps -fe | grep [进程关键字] # 得到pid
top -p [pid] # 使用pid查找内存

# 查看文件前后行, 直接找到行然后打印
tail -fn 1000 nohut.out [f循环打印 n行数 tail后几行]
head -n 1000 nohut.out [n行数 head前几行]

#监控TCP/IP网络并过滤指定端口
netstat -lanp|grep 8080
netstat -aon|grep ".27:80 "|wc

#查看磁盘空间
df -hl

#查看内存使用情况
free

#查找目录下的文件
find path -name 文件名

#查找当前目录下的以out结尾的文件
find . -name "*.out" 

# 其他简单命令
cat, vim, mkdir, cd, ll, ls 
```

## 操作系统权限管理

https://zhuanlan.zhihu.com/p/94240550: 一篇文章了解Linux操作系统的权限管理

https://www.cnblogs.com/starof/p/4350212.html: linux chmod命令和chown命令

基于用户角色 => 提供权限管理机制(UGO+RWX/ACL权限控制)

UGO => User, Group, Other

RWX => Read, Write, eXecute

ACL => Access Control List

**自主访问控制(Discretionary Access Control, DAC)** => 文件拥有者可以决定文件权限设置

SELinux => MAC(Mandatory Access Control)

![image-20220325003312826](https://s2.loli.net/2022/04/13/nuQH6S57vXdf8DU.png)

![img](https://s2.loli.net/2022/04/13/HthDMGmEAWkiPNU.jpg)

常规- 目录d 块设备b 连接l 字符设备c

常规文件 => - 

目录 => d

块设备 => b

链接 => l

字符设备 => c

后面三段是文件具体的权限描述信息了, 分别是==文件所有者==, ==组用户==权限和==其它用户==的权限.

1. **r表示对于该用户可读**，对于文件来说是允许读取内容，对于目录来说是允许读取其中的文件；
2. **w表示对于该用户可写**，对于文件来说是允许修改其内容，对于目录来说可以写信息到目录中，即可以创建、删除文件、移动文件等操作。
3. **x表示对于该用户可执行**, 目录的话可以被搜索.

**==chmod和chown==**

\+ 表示添加权限, - 表示删除权限, = 重置权限

r => 100(4), r => 010(2), x => 001(1),  - => 0

所以可以用数字来改 ==rwx r-x r--== => ==111 101 100== => 754

-rw------- (600) 只有所有者才有读和写的权限。

-rw-r--r-- (644) 只有所有者才有读和写的权限，群组和其他人只有读的权限。

-rw-rw-rw- (666)每个人都有读写的权限

-rwx------ (700) 只有所有者才有读，写和执行的权限。

-rwx--x--x (711) 只有所有者才有读，写和执行的权限，群组和其他人只有执行的权限。

-rwxr-xr-x  (755) 只有所有者才有读，写，执行的权限，群组和其他人只有读和执行的权限。

-rwxrwxrwx (777) 每个人都有读，写和执行的权限



**查看权限**

执行ls -l /a/b查看的并不是b的权限，而是c的权限。ls -l /a/b => 显示目标文件夹中的文件权限信息

- ls -l /a => 能看到b文件的权限
- ls -l /a/b => 能看到c文件的权限
- ls -l /a/b/c => 能看到c文件的权限

### **==chmod==**修改权限

u (user): 代表文件所有者.
g (group): 代表所有者所在的群组.
o (other): 代表其他人, 除了u,g以外的用户.
a (all): u, g, o全部

- chmod 700 /a 修改的是a文件的权限
- chmod 700 /a/b 修改的是b文件的权限
- chmod 700 /a/b/c修改的是c文件的权限

```shell
# chmod o+w file:表示给其他人授予写file这个文件的权限
# chmod go-rw file: 表示删除群组和其他人对file这个文件的读和写的权限
# chmod go-w+x mydir: 拒绝组成员和其他人创建或删除mydir(go-w）中文件的权限，允许组成员和其他人搜索mydir
```

### **==chown==** => 文件和目录权限可通过chomd来修改

```bash
chown yid [filename] # 修改文件主人为yid
chown :yid [filename] # 修改用户组为yid
chown yid:yid [filename] # 修改文件主人和用户组皆为yid
chown -r yid:yid [dirname] # 文件夹内全部设为yid和yid用户组的文件
```

```bash
[root@yl-web-test ~]# mkdir permission
[root@yl-web-test ~]# cd permission/
[root@yl-web-test permission]# ls
[root@yl-web-test permission]# touch file
[root@yl-web-test permission]# ll
total 0
-rw-r--r--. 1 root root 0 Aug  6 09:17 file # => root root => 所有者和用户组

# 修改修改file文件的所有者为lxy
[root@yl-web-test permission]# chown lxy file
[root@yl-web-test permission]# ll
total 0
-rw-r--r--. 1 lxy root 0 Aug  6 09:17 file

# 修改file文件的用户组为lxy
[root@yl-web-test permission]# chown root file
[root@yl-web-test permission]# ll
total 0
-rw-r--r--. 1 root root 0 Aug  6 09:17 file
[root@yl-web-test permission]# chown :lxy file
[root@yl-web-test permission]# ll
total 0
-rw-r--r--. 1 root lxy 0 Aug  6 09:17 file

# 同时修改所有者和用户组
[root@yl-web-test permission]# chown lxy:lxy file
[root@yl-web-test permission]# ll
total 0
-rw-r--r--. 1 lxy lxy 0 Aug  6 09:17 file

# 若修改文件夹下所有文件 => 用-R参数 (遍历?)
[root@yl-web-test permission]# chown -R lxy:lxy file
```

## 实例

```bash
# y
nohup java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof -jar /home/hik/data/ygw/ygw-1.0.0-SNAPSHOT.jar &

我曾在ssh登录时日志报错: /var/empty/sshd must be owned by root and not group or world-writable。
此时我就要看/var/empty/sshd的权限了。
用 # ll /var/empty/sshd去查结果是total 0，代表里面没有文件。
而真正应该用的命令是 # ll /var/empty，去查看它的上级目录。
然后就可以看到结果是: 
total 0
drwxrwxrwx. 2 root root 6 May 13 03:41 sshd
```

# 19. 大端和小端

来自于Jonathan Swift的《格利佛游记》

比如数据 `0x123456` 在两种情况下的存储形式

大端 => 字节高低位递增 => 地位 => 高位 => **判断正负**

```cpp
  低地址 -----> 高地址
  0x12 | 0x34 | 0x56 
      //大端模式由于符号位为第一个字节，很方便判断正负
```

小端 => 字节高低位递减 => 高位 => 低位 => **截取低字节**

```cpp
  低地址 -----> 高地址
  0x56 | 0x34 | 0x12 
      // 小端模式强制转换类型时不需要调整字节内容，直接截取低字节即可
```

ds