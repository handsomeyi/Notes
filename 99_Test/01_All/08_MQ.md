# ==MQTest==

什么是mq? 

你为什么用mq? 

为什么用mq? 

为什么不用ooxx? 

可靠性怎么保证? 

重复消息? 

丢失消息? 

---

## 目标: 架构能力

### MQ: 边界(queue)

【解耦. 异步. 消峰】: 发送文件(很大的东西)

message=size: kafka: 1M, rocketmq: 4M, rabbitmq: 2G, 512M

queue: FIFO, del, offset



producer: 投递可靠性

consumer: 消费可靠性

broker: 

partition: 

topic: 



amqp

exchange:direct,fanout,topic,headrs

queue:

binding:ex+queue

routingkey:ex+(routingkey)+queue

问题: dirct可不可以一个routingkey通过dirctEX发送给多个queue



延迟

过期

重试

死信

幂等

重复

可靠

有序

消息大小

发送机制



# ==MQ基础==

## 为什么使用MQ? MQ的优点

1. 主要是为了: **解耦, 异步, 削峰**. 

   - 异步处理 = 相比于传统的串行, 并行方式, 提高了系统吞吐量. 
   - 应用解耦 = 系统间通过消息通信, 不用关心其他系统的处理. 
   - 流量削锋 = 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求. 
   - 日志处理 = 解决大量日志传输. 
   - 消息通讯 = 消息队列一般都内置了高效的通信机制, 因此也可以用在纯的消息通讯. 比如实现点对点消息队列, 或者聊天室等. 

2. **解耦**: A 系统发送数据到 BCD 三个系统, 通过接口调用发送. 这种情况下A只需要维护对消息队列的提供功能, 不需要考虑人家怎么消费, 是否成功, 谁要消费, 与我无瓜. => 异步解耦化.

   **异步**: 就是说写入MQ成功就直接返回, 后续BCD的写库只要MQ消费完就OK.

   A 系统接收一个请求, 需要在自己本地写库, 还需要在 BCD 三个系统写库, 自己本地写库要 3ms, BCD 三个系统分别写库要 300ms, 450ms, 200ms. 最终请求总延时是 3 + 300 + 450 + 200 = 953ms, 接近 1s, 用户感觉搞个什么东西, 慢死了慢死了. 用户通过浏览器发起请求. 如果使用 MQ, 那么 A 系统连续发送 3 条消息到 MQ 队列中, 假如耗时 5ms, A 系统从接受一个请求到返回响应给用户, 总时长是 3 + 5 = 8ms. 

   **削峰**: 通过队列长度限制, 减少高峰时期对服务器压力. 

## 消息队列有什么优缺点? RabbitMQ有什么优缺点? 

**优点**: 异步, 解耦, 削峰.

**缺点**: 

- 系统可用性降低
- 系统复杂度提高: 重复消费, 可靠性传输
- 一致性问题

实际上消息队列是一个非常复杂的架构, 有利有弊, 但是改用还是得用, 也得对其缺点进行另外的处理.

## 你们公司生产环境用的是什么消息中间件? **综合对比如下**

- ActiveMQ => 老牌MQ, 过去用的多, 但现在对高并发不是特别支持, 对简单的异步, 解耦可用.
- RabbitMQ => erlang原生RabbitMQ, 高并发, 高吞吐, 性能很高, 可视化, 社区活跃.
- RocketMQ => 姓马云的马, 基于Java,  超高并发, 高吞吐, 性能卓越, 分布式事务.
- Kafka => 小于RocketMQ, 超高吞吐量的实时日志采集, 实时数据同步, 实时数据计算. (大数据体系)

## ==Kafka. ActiveMQ. RabbitMQ. RocketMQ== 有什么优缺点? 

|            | ActiveMQ                                               | RabbitMQ                                                     | RocketMQ                                                     | Kafka                                                        | ZeroMQ               |
| :--------- | :----------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | -------------------- |
| 单机吞吐量 | 比RabbitMQ低                                           | 2.6w/s(消息做持久化)                                         | 11.6w/s                                                      | 17.3w/s                                                      | 29w/s                |
| 开发语言   | Java                                                   | Erlang                                                       | Java                                                         | Scala/Java                                                   | C                    |
| 主要维护者 | Apache                                                 | Mozilla/Spring                                               | Alibaba                                                      | Apache                                                       | iMatix, 创始人已去世 |
| 成熟度     | 成熟                                                   | 成熟                                                         | 开源版本不够成熟                                             | 比较成熟                                                     | 只有C, PHP等版本成熟 |
| 订阅形式   | 点对点(p2p), 广播(发布=订阅)                           | 提供了4种: direct, topic ,Headers和fanout. fanout就是广播模式 | 基于topic/messageTag以及按照消息类型, 属性进行正则匹配的发布订阅模式 | 基于topic以及按照topic进行正则匹配的发布订阅模式             | 点对点(p2p)          |
| 持久化     | 支持少量堆积                                           | 支持少量堆积                                                 | 支持大量堆积                                                 | 支持大量堆积                                                 | 不支持               |
| 顺序消息   | 不支持                                                 | 不支持                                                       | 支持                                                         | 支持                                                         | 不支持               |
| 性能稳定性 | 好                                                     | 好                                                           | 一般                                                         | 较差                                                         | 很好                 |
| 集群方式   | 支持简单集群模式, 比如’主=备’, 对高级集群模式支持不好. | 支持简单集群, '复制’模式, 对高级集群模式支持不好.            | 常用 多对’Master=Slave’ 模式, 开源版本需手动切换Slave变成Master | 天然的‘Leader=Slave’无状态集群, 每台服务器既是Master也是Slave | 不支持               |
| 管理界面   | 一般                                                   | 较好                                                         | 一般                                                         | 无                                                           | 无                   |

- 一般的业务系统要引入 MQ, 最早大家都用 ActiveMQ, 但是现在确实大家用的不多了, 没经过大规模吞吐量场景的验证, 社区也不是很活跃, 所以大家还是算了吧, 我个人不推荐用这个了；
- 后来大家开始用 RabbitMQ, 但是确实 **erlang** 语言阻止了大量的 Java 工程师去深入研究和掌控它, 对公司而言, 几乎处于不可控的状态, 但是确实人家是**开源**的, 比较**稳定的支持**, **活跃度也高**；
- 不过现在确实越来越多的公司会去用 RocketMQ, 确实很不错, 毕竟是**阿里出品**, 但社区可能有突然黄掉的风险(目前 RocketMQ **已捐给 [Apache](https://github.com/apache/rocketmq)**, 但 GitHub 上的活跃度其实不算高)对自己公司技术实力有绝对自信的, 推荐用 RocketMQ, 否则回去老老实实用 RabbitMQ 吧, 人家有活跃的开源社区, 绝对不会黄. 
- 所以**中小型公司**, 技术实力较为一般, 技术挑战不是特别高, 用 RabbitMQ 是不错的选择；**大型公司**, 基础架构研发实力较强, 用 RocketMQ 是很好的选择. 
- 如果是**大数据领域**的实时计算, 日志采集等场景, **==用 Kafka 是业内标准的==**, 绝对没问题, 社区活跃度很高, 绝对不会黄, 何况几乎是全世界这个领域的事实性规范. 

## MQ 有哪些常见问题? 如何解决这些问题? 

**顺序问题**

- 保证生产者 = MQServer = 消费者是一对一对一的关系
- 缺陷:
  - 并行度就会成为消息系统的瓶颈(吞吐量不够)
  - 更多的异常处理, 比如: 只要消费端出现问题, 就会导致整个处理流程阻塞, 我们不得不花费更多的精力来解决阻塞的问题. 通过合理的设计或者将问题分解来规避. 
  - 不关注乱序的应用实际大量存在
  - 队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统, 是一种更合理的方式. 

**重复问题** => 根本原因: 网络不可达

- 使得消费者业务逻辑保持幂等性.
- 保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现. 

## 说说设计MQ思路? 

- 比如说这个消息队列系统, 我们从以下几个角度来考虑一下: 
- 首先这个 mq 得支持可伸缩性吧, 就是需要的时候快速扩容, 就可以增加吞吐量和容量, 那怎么搞? 设计个分布式的系统呗, 参照一下 kafka 的设计理念, broker => topic => partition, 每个 partition 放一个机器, 就存一部分数据. 如果现在资源不够了, 简单啊, 给 topic 增加 partition, 然后做数据迁移, 增加机器, 不就可以存放更多数据, 提供更高的吞吐量了? 
- 其次你得考虑一下这个 mq 的数据要不要落地磁盘吧? 那肯定要了, 落磁盘才能保证别进程挂了数据就丢了. 那落磁盘的时候怎么落啊? 顺序写, 这样就没有磁盘随机读写的寻址开销, 磁盘顺序读写的性能是很高的, 这就是 kafka 的思路. 
- 其次你考虑一下你的 mq 的可用性啊? 这个事儿, 具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制. 多副本 => leader & follower => broker 挂了重新选举 leader 即可对外服务. 

能不能支持数据 0 丢失啊? 可以的, 参考我们之前说的那个 kafka 数据零丢失方案. 

# ==RabbitMQ==

## 什么是RabbitMQ? 

**RabbitMQ是一款开源的, Erlang编写的, 基于AMQP协议的消息中间件**

**基于AMQP**
在服务器中, 三个主要功能模块连接成一个处理链完成预期的功能: 
“exchange”接收发布应用程序发送的消息, 并根据一定的规则将这些消息路由到“消息队列”. 
“message queue”存储消息, 直到这些消息被消费者安全处理完为止. 
“binding”定义了exchange和message queue之间的关联, 提供路由规则. 

## rabbitmq 的使用场景

- 服务间异步通信
- 顺序消费
- **定时任务**
- 请求削峰

## RabbitMQ基本概念

![image-20220416173245947](https://s2.loli.net/2022/04/16/uGXZqwaHVg8tk9U.png)

- **Broker**:  简单来说就是消息队列服务器实体
- **Exchange**:  消息交换机, 它指定消息按什么规则, 路由到哪个队列
- **Queue**:  消息队列载体, 每个消息都会被投入到一个或多个队列
- **Binding**:  绑定, 它的作用就是把**exchange和queue**按照路由规则绑定起来
- **Routing Key**:  路由关键字, exchange根据这个关键字进行消息投递
- **VHost**:  vhost 可以理解为虚拟 broker , 即 mini-RabbitMQ server. 其内部均含有独立的 queue、exchange 和 binding 等, 但最最重要的是, 其拥有独立的权限系统, 可以做到 vhost 范围的用户控制. 当然, 从 RabbitMQ 的全局角度, vhost 可以作为不同权限隔离的手段(一个典型的例子就是不同的应用可以跑在不同的 vhost 中). 
- **Producer**:  消息生产者, 就是投递消息的程序
- **Consumer**:  消息消费者, 就是接受消息的程序
- **Channel**:  消息通道, 在客户端的每个连接里, 可建立多个channel, 每个channel代表一个会话任务

由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路. 

**RabbitMQ高可用集群**

![image-20220416173850260](https://s2.loli.net/2022/04/16/wCtkfTLWmyg2MXh.png)

## RabbitMQ的工作模式

- **simple模式(即最简单的收发模式)**

  ![img](https://s2.loli.net/2022/04/16/TefjsyzEotHxI4d.png)

  消费者拿走消息后, 队列自动删除消息, 为了保证正确消费, 可手动设置ack, 正确消费完及时返回ack, 否则会导致内存溢出.

- **work工作模式(资源的竞争)**

  ![img](https://s2.loli.net/2022/04/16/V13byd4lCDSrL2x.png)

  消费者可以有多个, 同时监听同一个队列, 防止重复消费**得加锁**(synchronized).

- **publish/subscribe发布订阅(共享资源)**

  ![img](https://s2.loli.net/2022/04/16/ZBucR3nIOt5h4XP.png)

  每个消费者监听自己的队列, 生产者发给broker, 通过exchange转发到此交换机的每个队列.

  ==避免了重复消费, 不用加锁==.

- **routing路由模式**

  ![img](https://s2.loli.net/2022/04/16/Foe4TYtsZKbwU6N.png)

  **交换机**根据消息的一个**info**字符串, 来决定**路由到哪个**消息队列.

  这个路由逻辑可自行实现.

  业务场景: error 通知, Exception, 错误通知, 客户通知等.

  自定义key路由, 吧错误封装成消息, 根据错误类型发送到不同queue, 定制不同处理器consumer解决错误.

- **topic 主题模式(增加了模糊匹配的路由模式)**

  ![img](https://s2.loli.net/2022/04/16/yRo64lAW1PqIjgB.png)

  星号井号代表通配符

  星号代表多个单词,井号代表一个单词

  路由功能添加模糊匹配

  消息产生者产生消息,把消息交给交换机

  交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费

  (在我的理解看来就是routing查询的一种模糊匹配, 就类似sql的模糊查询方式)

## 如何保证RabbitMQ消息的顺序性? 

- 拆分多个 queue, 每个 queue 一个 consumer, 就是多一些 queue 而已, 确实是麻烦点；
- 或者就一个 queue 但是对应一个 consumer, 然后这个 consumer 内部用内存队列做排队, 然后分发给底层不同的 worker 来处理. (? 感觉也不严谨, 如何保证底层worker顺序处理呢, 各个worker有相互通讯机制? )

## 消息如何分发? 

- 单个队列多个消费者: 循环(round-robin)分发,.
- 多个队列各自消费者: 通过 **路由模式交换机** + **info字符串** 实现业务相关的分发.

## 消息怎么路由? 

消息提供方->路由->一至多个队列消息发布到交换器时, 消息将拥有一个路由键(routing key), 在消息创建时设定. 通过队列路由键, 可以把队列绑定到交换器上. 消息到达交换器后, RabbitMQ 会将消息的路由键与队列的路由键进行匹配(针对不同的交换器有不同的路由规则)；

常用的交换器主要分为一下三种: 

fanout: 如果交换器收到消息, 将会广播到所有绑定的队列上

direct: 如果路由键完全匹配, 消息就被投递到相应的队列

topic: 可以使来自不同源头的消息能够到达同一个队列.  使用 topic 交换器时, 可以使用通配符

## 消息基于什么传输? 

- TCP连接创建与销毁开销大, 并发数受系统资源限制, 造成性能瓶颈.

- 信道的方式来传输数据

  信道是基于TCP连接的虚拟连接, 并且TCP链接上的信道数量没有限制.

  **信道之于TCP连接 => 协程之于线程**

## 如何保证消息不被重复消费? 或者说, 如何保证消息消费时的幂等性? 

- 为何会重复消费?

  因为网络传输不是完全可靠的, ack可能没有返回到队列, 队列不知道被消费过 => 重复消费.

- 解决方案 ==(**额外冗余处理**与**提前判断**的取舍 => 谁快用谁)==

  ​	**额外冗余处理:** 保持消息处理逻辑的幂等性

  ​	**提前判断**: 写入消息队列时做唯一标识, 消费时, 判断此标识是否被消费过
  

## 如何确保消息正确地发送至 RabbitMQ?  如何确保消息接收方消费了消息? 

- **发送方确认模式**

  将信道设置成 confirm 模式(发送方确认模式), 则所有在信道上发布的消息都会被指派一个唯一的 ID. 
  一旦消息被投递到目的队列后, 或者消息被写入磁盘后(可持久化的消息), 信道会发送一个确认ack给生产者(包含消息唯一 ID). 
  如果 RabbitMQ 发生内部错误从而导致消息丢失, 会发送一条 nack(notacknowledged, 未确认)消息. 
  发送方确认模式是异步的, 生产者应用程序在等待确认的同时, 可以继续发送消息. 当确认消息到达生产者应用程序, 生产者应用程序的回调方法就会被触发来处理确认消息. 

- **接收方确认机制**

  消费者接收每一条消息后都必须进行确认(消息接收和消息确认是两个不同操作). 只有消费者确认了消息, RabbitMQ 才能安全地把消息从队列中删除. 

  这里并没有用到超时机制, RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息. 也就是说, 只要连接不中断, RabbitMQ 给了 Consumer 足够长的时间来处理消息. 保证数据的最终一致性；

  下面罗列几种特殊情况

  - 如果消费者接收到消息, 在确认之前断开了连接或取消订阅, RabbitMQ 会认为消息没有被分发, 然后重新分发给下一个订阅的消费者. (可能存在消息重复消费的隐患, 需要去重)
  - 如果消费者接收到消息却没有确认消息, 连接也未断开, 则 RabbitMQ 认为该消费者繁忙, 将不会给该消费者分发更多的消息. 

## 如何保证RabbitMQ消息的可靠传输? 

有可能产生消息丢失.

丢失分为如下三种

- **生产者丢失消息** => transaction和confirm模式

  从生产者弄丢数据这个角度来看, RabbitMQ提供transaction和confirm模式来确保生产者不丢消息；

  transaction机制就是说: 发送消息前, 开启事务（channel.txSelect()）,然后发送消息, 如果发送过程中出现什么异常, 事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）. 然而, 这种方式有个缺点: 吞吐量下降；

  confirm模式用的居多: 一旦channel进入confirm模式, 所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始）, 一旦消息被投递到所有匹配的队列之后；

  rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID）, 这就使得生产者知道消息已经正确到达目的队列了；

  如果rabbitMQ没能处理该消息, 则会发送一个Nack消息给你, 你可以进行重试操作. 

- **消息队列丢数据** => 消息持久化

  处理消息队列丢数据的情况, 一般是开启持久化磁盘的配置. 

  这个持久化配置可以和confirm机制配合使用, 你可以在消息持久化磁盘后, 再给生产者发送一个Ack信号. 

  这样, 如果消息持久化磁盘之前, rabbitMQ阵亡了, 那么生产者收不到Ack信号, 生产者会自动重发. 

  那么如何持久化呢？

  这里顺便说一下吧, 其实也很容易, 就下面两步

  1. 将queue的持久化标识durable设置为true,则代表是一个持久的队列
  2. 发送消息的时候将deliveryMode=2

  这样设置以后, 即使rabbitMQ挂了, 重启后也能恢复数据

- **消费者丢失消息** => 自动确认消息模式, 手动返回ack即可

  消费者在收到消息之后, 处理消息之前, 会自动回复RabbitMQ已收到消息；

  如果这时处理消息失败, 就会丢失该消息；

  解决方案: 处理消息成功后, 手动回复确认消息. 

## 为什么不应该对所有的 message 都使用持久化机制? 

- 写磁盘必然导致效率低 => 可能有10倍的吞吐量差距.

- RabbitMQ内置cluster方案的坑

  **message => persistent, queue => no durable**

  那么当该 queue 的 owner node 出现异常后, 在未重建该 queue 前, 发往该 queue 的 message 将被 blackholed

  **message => persistent, queue => durable**

  那么当 queue 的 owner node 异常且无法重启的情况下, 则该 queue 无法在其他 node 上重建, 只能等待其 owner node 重启后, 才能恢复该 queue 的使用, 而在这段时间内发送给该 queue 的 message 将被 blackholed

- 是否持久化, 需要结合业务和性能要求设计, 若想达到单机10w吞吐量

  ​	1. 可用SSD快速持久化

  ​	2. 关键信息持久化.

## 如何保证高可用的? RabbitMQ 的集群

图见第一点

![image-20220416173850260](https://s2.loli.net/2022/04/16/XrKcngVuBpa6Iy3.png)

RabbitMQ基于主从实现高可用 => 两种, 普通集群模式, 镜像集群模式.

- **普通集群模式** => 虚假的高可用 => 提高吞吐量

  多个机器启动RabbitMQ实例, 生产者发过来的消息只会放在一个RabbitMQ实例, 其他实例同步的是queue的元数据(通过元数据找到实际queue), 然后拉取实际数据过来.
  实际上就是多个节点服务某个queue读写, 主要是提高吞吐量的.

- **镜像集群模式** => 真实的高可用 => 真·高可用

  多个机器启动RabblitMQ, 并且所有数据都和元数据都在每个queue上, 每次写消息伴随着大量同步.
  某个机器宕机了, 它的consumer也可以去其他节点上消费数据, 真·高可用.

  缺点在于: 如果消息多, 大量同步造成的网络带宽消耗问题.

## 如何解决消息队列的延时以及过期失效问题? 

- **MQ中消息失效** => 手动重新发到MQ

  如果用的RabbitMQ, 它是可以设置过期时间(TTL)的, 如果积压过久的消息会被清理掉.
  只能大家一起喝杯咖啡, 等高峰期过去后, 等用户睡觉了, 把丢失数据用临时程序查出来, 重新灌入MQ即可.
  也只能是这样了. 假设 1 万个订单积压在 mq 里面, 没有处理, 其中 1000 个订单都丢了, 你只能手动写程序把那 1000 个订单给查出来, 手动发到 mq 里去再补一次. 

## 消息队列满了以后该怎么处理? 有几百万消息持续积压几小时, 说说怎么解决? 

- **消息积压 => 临时紧急扩容**

  先修复consumer的问题, 确保其消费速度没问题, 然后停掉所有consumer.
  临时处理: 新建一个topic, partition是原来的10倍, 建好原先十倍的queue数量.
  写一个临时分发数据的consumer程序, 把MQ中积压的数据轮询写入临时10倍queue.
  然后用10倍consumer的机器部署consumer, 对接好queue之后, 10倍速率消费消息.
  消费完积压数据后, 恢复原先架构.

- **MQ队列快满了** => 临时程序接入消息消费一个丢弃一个, 快速消费巨量数据.
  然后还要注意过期消息的补充, 晚上补数据吧.

# ==Kafka==

## 基础题

## 1. Apache Kafka 是什么?

Kafka 是一款**==分布式流处理框架==**，用于**==实时构建流处理应用==**。它有一个核心 的功能广为人知，即作为**==企业级的消息引擎==**被广泛使用。

## 2. 什么是消费者组?(Kafka独有)

- **定义**: 

  即消费者组是 Kafka 提供的**可扩展**且具**有容错性**的消费者机制。

- **原理**:

  在 Kafka 中，消费者组是一个由多个消费者实例 构成的组。多个实例共同订阅若干个主题，实现共同消费。同一个组下的每个实例都配置有 相同的组 ID，被分配不同的订阅分区。当某个实例挂掉的时候，其他实例会自动地承担起 它负责消费的分区。

- 消费者组的题目方向(引导面试方向)

  移值原理 => **消费者组的位移提交机制**
  Kafka Broker => **消费者组与 Broker 之间的交互**
  Producer => yid: "**消费者组要消费的数据完全来自于 Producer 端生产的消息, 我对 Producer 还是比较熟悉的**"

## 3. 在 Kafka 中, ZooKeeper 的作用是什么?

- **目前**

  Kafka 使用 ZooKeeper 存放集群元数据、成员管理、Controller 选举，以及其他一些管理类任务。

- **将来**

## 4. 解释下 Kafka 中位移(offset)的作用

## 5. 阐述下 Kafka 中的领导者副本(Leader Replica)和追随者副本 (Follower Replica)的区别

## 6. 如何设置 Kafka 能接收的最大消息的大小?

## 7. 监控 Kafka 的框架都有哪些?

## 8. Broker 的 Heap Size 如何设置?

## 9. 如何估算 Kafka 集群的机器数量?

## 10. Leader 总是 =1, 怎么破?



## 提高题

## 1.Kafka 的设计时什么样的呢? 

## 2.数据传输的事务定义有哪三种? 

## kafka事务. 

## 3.Kafka 判断一个节点是否还活着有那两个条件? 

## 4.producer 是否直接将数据发送到 broker 的 leader(主节点)? 

## 5. Kafa consumer 是否可以消费指定分区消息? 

## 6. Kafka 消息是采用 Pull 模式, 还是 Push 模式? 

## 7.Kafka 存储在硬盘上的消息格式是什么? 

## 8.Kafka 高效文件存储设计特点: 

## 9.Kafka 与传统消息系统之间有三个关键区别

## 10.Kafka 创建 Topic 时如何将分区放置到不同的 Broker 中

## 11.Kafka 新建的分区会在哪个目录下创建

## 12.partition 的数据如何保存到硬盘

## 13.kafka 的 ack 机制

## 14.Kafka 的消费者如何消费数据

## 15.消费者负载均衡策略

## 16.数据有序

## 17.kafaka 生产数据时数据的分组策略



## 深度思考题

## 11. LEO. LSO. AR. ISR. HW 都表示什么含义?

## 12. Kafka 能手动删除消息吗?

## 13. __consumer_offsets 是做什么用的?

## 14. 分区 Leader 选举策略有几种?

## Kafka中有那些地方需要选举? 这些地方的选举策略又有哪些? 

## 15. Kafka 的哪些场景中使用了零拷贝(Zero Copy)?

## 16. Kafka 为什么不支持读写分离?

## 17. 如何调优 Kafka?

## 18. Controller 发生网络分区(Network Partitioning)时, Kafka 会怎 么样?

## 19. Java Consumer 为什么采用单线程来获取消息?

## 20. 简述 Follower 副本消息同步的完整流程



## 重点: kafka如何实现高吞吐? 

1. 简单说说: kafka如何实现高吞吐? 



2 Kafka如何实现每秒上百万的超高并发写入? 

页缓存技术 + 磁盘顺序写

零拷贝技术



# ==RocketMQ==

多个MQ如何选型? 



## 基础题

## RocketMQ组成部分(角色)有哪些? 

## RocketMQ消费模式有几种?

## 消息重复消费如何解决? 

## RocketMQ如何保证消息的顺序消费? 

## RocketMQ如何保证消息不丢失? 

## RocketMQ 由哪些角色组成? 

## RocketMQ执行流程

## 请说说你对 Producer 的了解? 

## 说说你对 Consumer 的了解? 

## 消费者消费模式有几种? 

## 消费者获取消息有几种模式? 

## 什么是定时消息? 如何实现? 



## 提高题

## RocketMQ如何实现分布式事务? 

## RocketMQ的消息堆积如何处理? 

