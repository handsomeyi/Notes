# schema与数据类型优化

## 整型

**TINYINT**(8), **SMALLINT**(16), **MEDIUMINT**(32), **INT**(64), **BIGINT **位存储空间.

1. 整型比字符操作代价更低, 因为字符集和校对规则更复杂.

2. 使用mysql自建类型而不是字符串来存储日期和时间

3. 用整型存储IP地址

   **MySQL: **

   **select INET_ATON('192.168.85.100')**

   **select INET_NTOA('1234131526')**

   **得到相互转换**

## 不应该出现null

如果查询中包含可为NULL的列, 对mysql来说很难优化, 因为可为null的列使得索引、索引统计和值比较都更加复杂, 

## 字符类型

### varchar根据实际长度保存数据

1. varchar(n) n小于等于255使用额外一个字节保存长度, n>255使用额外两个字节保存长度。
2. varchar(5)与varchar(255)保存同样的内容, 硬盘存储空间相同, 但内存空间占用不同, 是指定的大小 。
3. MySQL5.6之前: 从255提高到255以上时, 都会导致锁表.

### char固定长度的字符串

1. 最大长度255
2. 会自动删除末尾的空格 trim()
3. 检索写效率比varchar高

例子: md5摘要.

### BLOB TEXT

BOLB 二进制存储形式

TEXT 字符存储形式

### datetime(8) timestamp(4) 字节

datetime 范围大

timestamp 范围: 1970-01-01到2038-01-19

date(3) 可以用函数计算

### 枚举替代字符串

==**自动映射为整型 方便存储**==

有时可以使用枚举类代替常用的字符串类型, mysql存储枚举类型会非常紧凑, 

会根据列表值的数据压缩到一个或两个字节中, mysql在内部会将每个值在列表中的位置保存为整数, 并且在表的.frm文件中保存“数字-字符串”映射关系的查找表

```sql
--                               1      2      3
create table enum_test(e enum('fish','apple','dog') not null);
insert into enum_test(e) values('fish'),('dog'),('apple');
select e+0 from enum_test;
```

# 范式

(超过三张表 禁止join)

**范式化**后冗余数据较少

**反范式**不一定不好(看业务情况)

## 案例

- 在一个网站实例中，这个网站，允许用户发送消息，并且一些用户是付费用户。现在想查看付费用户最近的10条信息。  **在user表和message表中都存储用户类型(account_type)而不用完全的反范式化**。这避免了完全反范式化的插入和删除问题，因为即使没有消息的时候也绝不会丢失用户的信息。这样也不会把user_message表搞得太大，有利于高效地获取数据。

- 另一个从父表**冗余一些数据到子表**的理由是排序的需要。

- **缓存衍生值也是有用的**。如果需要显示每个用户发了多少消息（类似论坛的），可以每次执行一个昂贵的自查询来计算并显示它；也可以在user表中建一个num_messages列，每当用户发新消息时更新这个值。



**范式与反范式不一定谁更好**

![image-20220303143128333](https://s2.loli.net/2022/03/03/rCFvwR41Ix3AHoT.png)

---------------------------------------------------------------------------------------------------------------------------

![image-20220303143141465](https://s2.loli.net/2022/03/03/aN6WiRJuwvox8ct.png)

# 主键的选择

### 代理主键

不与业务耦合, 易于维护

### 自然主键

事物自然属性值作为主键

### 推荐使用代理主键

应该实用无意义的代理主键 并不是以qq号为主键

# 字符集的选择

纯拉丁字符能表示的内容 => latin1

有中文才utf-8

# 存储引擎的选择

my.ini配置文件里面设置默认值

![image-20220303144358823](https://s2.loli.net/2022/03/03/Sf9lTEcPkO8wrUJ.png)

索引文件和数据文件放在一起 => **聚簇索引**

索引文件和数据文件不在一起 => **非聚簇索引**

# 适当的数据冗余

冗余为了方便查询, 但一定要保证数据一致性

# 适当分表

当表中存在TEXT或大VARCHAR并且访问量不大时, 应该单独拆出来一个表.

每个数据块所存的数据条数会更多, 提高缓存命中率.(结合LRU缓存思考)