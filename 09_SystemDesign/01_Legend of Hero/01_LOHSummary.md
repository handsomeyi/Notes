# coc游戏服务器架构分析

http://t.csdn.cn/8vHSc

# 为什么用Protobuf

Google的成熟消息协议框架

Protobuf简单介绍一下?

使用流程

```powershell
# 先配置好protoc的环境变量 => PATH => 也就是bin目录
# protoc.exe 看看能不能运行起来
protoc.exe
# 配置好javaout目录 直接生成代码  后面的目录就是proto文档位置(我在文档w)
protoc.exe --java_out=
D:\sourse\1ForInternetArchitect\LegendOfHero\HeroStory\src\main\java .\GameMsgProtocol.proto
```



# 用PackageUtil工具类空格问题

在利用这个工具类的时候获取clazzSet, 就是想把所有类型的消息处理器放到一个set里头
结果在debug的时候发现 => 源码意外里面发现本地path的url => 里面有一个 %20 
之前在利用protobuf生成java代码的时候也遇见过, 所以就在path上找问题
因为这个util没有对空格形式特殊处理, 所以set一直没找到, 消息一直没被处理.
我又认为这个命名不规范, 我索性就把文件夹名字去掉了空格.

# 低级错误

把build好的msg对象弃之而不用, 只用它做了一个判空处理. (而且idea也没提示, 因为我用到了msg对象)
然后实际该用它的时候填错了, 填的是原本的消息体(一个字节数组) => 一直出错
也是debug的时候发现了...



# 消息解码器和消息编码器流程?



# 角色入场, 角色移动, 以及角色离场?

channelGroup广播消息







# 排行榜系统是如何实现的?

Redis + RocketMQ

是存在库里 => 用户要的时候才返回(并不是实时的)

1. **服务器生产数据 userId 击杀次数 死亡次数 => 发给RocketMQ**
2. **RocketMQ => 排行榜进程(排名逻辑处理) => 写到Redis**
3. **最后用户再要排名的时候再从Redis取排名数据**

- 需求

  - 根据击杀胜利次数进行排名；

  - 显示排名 Id、用户头像、用户名称、胜利次数；

  - 最多显示 10 个用户；
- 实现
  - 修改 Protobuf 消息协议文档；
  - 增加 GetRankCmd 和 GetRankResult；
  - 增加 GetRankCmdHandler 类；
  - 修改 UserAttkCmdHandler 类完成排行榜功能；

- Redis命令

  - hset, hget (哈希表存取) => 设

    ```redis
    hset User_1 BasicInfo "{userId:1}"
    hset User_1 kill 2
    hset User_1 die 1
    ```

  - hincrby(线程安全增加)

    ```redis
    hincrby User_1 kill 1
    Integer 3
    ```

  - zadd(设置一个zset)

  - zrange(升序), zrevrange(降序)

# 如果给100万人排序怎么排?

https://blog.codingnow.com/2014/03/mmzb_db_2.html


# 日志系统用的什么? FEK是什么?

用的FileBeat(收集) + Elasticsearch(存储, 搜索) + Kibana(展示)

**LogStash or Filebeat?**

因为**logstash是jvm跑的, 资源消耗比较大**, 所以后来作者**又用golang写了**一个功能较少但是资源消耗也小的轻量级的logstash-forwarder. 后来改名叫Filebeat.

![image-20220324003302290](https://s2.loli.net/2022/04/10/tqDcwlis3fRuCAO.png)

配置完后他会自动帮你捞日志 => 直接通过Kibana看就行啦! 

如何**配置**?

装好Filebeat => 修改filebeat.yml配置文件 => 

配置log目录位置, 配置es网络位置, Kibana网络位置



# 反射实现ORM, 并且用javassist优化.

- 如果用硬编码, 把User对象和数据库关联. => 扩展性不高, 每次还要修改代码.
- 用自定义注解, 给User类注解上, 然后利用反射把注解字段取出来. => 扩展性高,  自动获取所有字段并关联. 但是它慢!

所以, 咱们可以用javassist加速反射!

javassist的原理就是用 StringBuffer和Ct 动态生成所需class文件, 省去编译过程.

只要是用到反射动态修改代码就能用javassist优化.

# 如何同步? 状态同步? 帧同步?

咱们这个用的是状态同步 => state 记录移动时的状态.





## 帧同步
​        帧同步的代表作当属当下最火的手游王者荣耀了吧，它就是帧同步完成的，也意味着它的核心的战斗逻辑写在客户端。帧同步经常被采用在RTS游戏（Real-Time Strategy ）中。在游戏中，又客户端给服务器上传玩家的指令，服务器收到指令之后不做任何操作然后转发给所有的客户端。客户端来运算包括技能逻辑、普攻、属性，伤害、移动、Al、检测、碰撞等一系列的内容，这也是游戏中最核心和最难的部分。所有的客户端运算完成所有接收到的指令，并且修改相应的属性和对应的特效。

## 状态同步
​        状态同步和帧同步是相反的，它最核心的一系列东西都写在服务器端。当客户端发送要进行操作给服务器，服务器进行一系列的操作运算，然后把相应的结果发送给所有的客户端，客户端接到数据后修改属性。这里客户端相当于服务器的播放器一样，因为核心的判断都是在服务器的，一切的表现和属性都以服务器为准，就算客户端的血条是满的，服务器的血条是0，那依旧要死。

例子：一个角色要释放一个技能（非指向技能），

客户端告诉服务器我要释放一个技能
服务器通知所有客户端在某个地方以什么方向释放技能
客户端根据收到的信息创建一个特效放在这个地方，然后以某个方向飞行
服务器根据碰撞检测判断到某个时刻碰到了地方英雄，通知客户端
客户端根据服务器发来的信息删除特效，被打到的人减少血量播放收击特效



## 帧同步和状态同步的区别

1. 流量
        状态同步的消耗的流量比帧同步要多的多，因为状态同步所有的属性都是在服务器的，当某个角色的属性变化之后都需要同步给所有客户端，而且在一些复杂一些的玩家角色的属性有上百条，这样同步下来消耗是巨大的。而帧同步不需要做属性同步，服务器只需要做一次转发操作指令，属性这些都是客户端自己计算，所以消耗少的多。

2. 回放和观战
        帧同步比状态同步简单，因为只需要保存每局内所有人的操作就好了，当回放的时候只需要挨个播放这局所有的操作就好。状态同步需要有一个专门的服务器，当一局战斗打响，服务器给客户端发送消息的同时，还需要把这些消息发送给这个专门的服务器做存储，当有人看回放或者观战时，这个专门的服务器把存储起来的消息发就可以了

3. 安全性
        状态同步比帧同步安全性高很多，因为状态同步的所有数据和逻辑都是在服务器端保存的，要想作弊就必须修改服务器的值，这样难度就会高很多；而帧同步所有的数据时在客户端，只要解析客户端的数据之后就可以达到自己想要的效果。

4. 断线重连
           帧同步的锻炼重连时比较麻烦的，当你在10分钟的时候断线了，在15分钟回来，就需要把服务器这15分钟的消息一次性的发送给客户端，然后客户端加速整个游戏的核心逻辑运算，直到追上现有进度。状态同步很简单，重新把整个场景中的任务全部重新生成一边，各种数值根据服务端提供的信息加到任务身上即可。

5. 开发效率
状态同步的游戏占主流，同一个功能至少需要一个客户端和服务器共同完成，开发起来比较困难。而帧同步服务器开发难度低，服务器只需要转发，而帧同步不需要和服务器的沟通交状态同步，开发的效率也高。

# 把登陆 查库的逻辑 异步化!

就是把查库送去另一个线程(asyncOp.doAsync();) => 数据库IO
让他查库, 查完之后, 回调函数继续执行逻辑(doFinish). => 回调继续

防止主厨师出来传菜 => 查库就是传菜 => 防止主线程去查库

## 异步优缺点

参考: http://t.csdn.cn/JAdYo

**优点**

1) I/O受限 => 异步能提高性能
2) 增强系统健壮性  
3) 改善用户体验 => (减少其他用户的响应时间)

**缺点**

1) 滥用异步, 会影响性能
2) 增加编程难度   

**异步实现**

1. 专用线程

   ```java
   System.Threading.ThreadStart ts = new System.Threading.ThreadStart(void(object state) target);   
   System.Threading.Thread th = new System.Threading.Thread(ts);   
   ts.Start();   
   ```

   调用 Start()方法之前, 并没有实质性得创建线程资源, 而是 Start()后才进行创建, 此种方式的好
   处在于能设置线程是前台线程还是后台线程, 并且能控制线程的挂起和消亡   

2. 线程池

   ```java
   // 都是后台线程
   ThreadPool.QueueUserWorkItem(WaitCallback callback) 
   ```


3. 使用异步编程模型 

   ```java
   BeginXXX(…IAsyCallBack callback, object asyState); 
   EndXXX(IAsyState ar); //这种模型的好处上面已经有所阐述
   ```


4) 使用 BackgroundWorker
   .Net2.0 下提供了 BackgroundWorker, 使用它可以轻易的完成异步操作, 并且它还有一些功能
   上的加强, 比如取消操作

