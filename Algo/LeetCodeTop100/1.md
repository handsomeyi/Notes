# 7.[整数反转](https://leetcode-cn.com/problems/reverse-integer)(防止溢出)

1. res结果是负数, 如果比系统最小/10 还小, 那么乘10之后必溢出

2. 如果res == m, 则乘10之后不溢出, 但是模出来的数x%/10如果系统最小模10, 则加上这部分必溢出
3. 因为负数可以兼顾正负两种情况, 所以可以通用!

```java
public static int reverse(int x) {
   boolean neg = ((x >>> 31) & 1) == 1;
   x = neg ? x : -x;
   int m = Integer.MIN_VALUE / 10;
   int o = Integer.MIN_VALUE % 10;
   int res = 0;
   while (x != 0) {
      if (res < m || (res == m && x % 10 < o)) {//某一种判断的时候 要多用到 短路或 拆分条件 性能更加优秀
         return 0;
      }
      res = res * 10 + x % 10;
      x /= 10;
   }
   return neg ? res : Math.abs(res);
}
```

# 8.[字符串转换整数](https://leetcode-cn.com/problems/string-to-integer-atoi) (atoi-溢出)

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
返回整数作为最终结果。
链接：https://leetcode-cn.com/problems/string-to-integer-atoi

核心逻辑:

```java
public static int myAtoi(String s) {
   // str 是符合日常书写的，正经整数形式
   boolean posi = str[0] == '-' ? false : true;
   int minq = Integer.MIN_VALUE / 10;
   int minr = Integer.MIN_VALUE % 10;
   int res = 0;
   int cur = 0;
   for (int i = (str[0] == '-' || str[0] == '+') ? 1 : 0; i < str.length; i++) {
      // 3  cur = -3   '5'  cur = -5    '0' cur = 0
      cur = '0' - str[i];
      if ((res < minq) || (res == minq && cur < minr)) {
         return posi ? Integer.MAX_VALUE : Integer.MIN_VALUE;
      }
      res = res * 10 + cur;
   }
   // 数是整数 且res等于系统最小 就返回系统最大 还是溢出了
   if (posi && res == Integer.MIN_VALUE) {
      return Integer.MAX_VALUE;
   }
   return posi ? -res : res;
}
```



# 12.[整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman)

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给你一个整数，将其转为罗马数字。
链接：https://leetcode-cn.com/problems/integer-to-roman

```java
public static String intToRoman(int num) {
		String[][] c = { 
				{ "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX" },
				{ "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC" },
				{ "", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM" },
				{ "", "M", "MM", "MMM" } };
		StringBuilder roman = new StringBuilder();
		roman
		.append(c[3][num / 1000 % 10])
		.append(c[2][num / 100 % 10])
		.append(c[1][num / 10 % 10])
		.append(c[0][num % 10]);
		return roman.toString();
	}
```

# 13.[罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer)

I             1
V             5
X             10
L             50
C             100
D             500
M             1000

直接遍历罗马数 如果比下一位小就是负当前数 否则就是本身

然后累加

```java
for (int i = 0; i < nums.length - 1; i++) {
			if (nums[i] < nums[i + 1]) {
				sum -= nums[i];
			} else {
				sum += nums[i];
			}
		}
```

# 14.最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。



直接一个一个看 如果不匹配就截断

```java
    public static String longestCommonPrefix(String[] strs) {
		if (strs == null || strs.length == 0) {
			return "";
		}
		char[] chs = strs[0].toCharArray();
		int min = Integer.MAX_VALUE;
		for (String str : strs) {
			char[] tmp = str.toCharArray();
			int index = 0;
			while (index < tmp.length && index < chs.length) {
				if (chs[index] != tmp[index]) {
					break;
				}
				index++;
			}
			min = Math.min(index, min);
			if (min == 0) {
				return "";
			}
		}
		return strs[0].substring(0, min);
	}
```

# 17.[电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number)(前缀树-深度优先遍历)

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number
![img](https://s2.loli.net/2021/12/23/ot9EOk4zyMuZewA.png)

```java
public static char[][] phone = { 
      { 'a', 'b', 'c' }, // 2    0
      { 'd', 'e', 'f' }, // 3    1
      { 'g', 'h', 'i' }, // 4    2
      { 'j', 'k', 'l' }, // 5    3
      { 'm', 'n', 'o' }, // 6    
      { 'p', 'q', 'r', 's' }, // 7 
      { 't', 'u', 'v' },   // 8
      { 'w', 'x', 'y', 'z' }, // 9
};

// "23"
public static List<String> letterCombinations(String digits) {
   List<String> ans = new ArrayList<>();
   if (digits == null || digits.length() == 0) {
      return ans;
   }
   char[] str = digits.toCharArray();
   char[] path = new char[str.length];
   process(str, 0, path, ans);
   return ans;
}
//深度优先遍历 收集沿途答案
public static void process(char[] str, int index, char[] path, List<String> ans) {
   if (index == str.length) {
      ans.add(String.valueOf(path));
   } else {
      char[] cands = phone[str[index] - '2'];
      for (char cur : cands) {
         path[index] = cur;
         process(str, index + 1, path, ans);
      }
   }
}
```

# 19.[删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)(同步指针)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

![image-20211223133359840](https://s2.loli.net/2021/12/23/trhgpbuxQTomBzI.png)

```java
	public static class ListNode {
		public int val;
		public ListNode next;
	}
	public static ListNode removeNthFromEnd(ListNode head, int n) {
		ListNode cur = head;
		ListNode pre = null;
		while (cur != null) {
			n--;
			if (n == -1) {
				pre = head;
			}
			if (n < -1) {
				pre = pre.next;
			}
			cur = cur.next;
		}
		if (n > 0) {
			return head;
		}
		if (pre == null) {
			return head.next;
		}
		pre.next = pre.next.next;
		return head;
	}

```



# 20.[有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)(辅助栈)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。



左括号压栈

右括号弹出 匹配

匹配成功继续 匹配失败返回false

如果遍历完了 栈还得必须是空的 否则返回false

最后才返回true

![image-20211223134814774](https://s2.loli.net/2021/12/23/uQYkNVm1hegZWDK.png)



#### 用数组替代栈   int size代替栈大小

#### 数组替代HashMap 前提是范围确定 并且数小

```java
public static boolean isValid(String s) {
		if (s == null || s.length() == 0) {
			return true;
		}
		char[] str = s.toCharArray();
		int N = str.length;
		char[] stack = new char[N];
		int size = 0;
		for (int i = 0; i < N; i++) {
			char cha = str[i];
			if (cha == '(' || cha == '[' || cha == '{') {
				stack[size++] = cha == '(' ? ')' : (cha == '[' ? ']' : '}');
			} else {
				if (size == 0) {
					return false;
				}
				char last = stack[--size];
				if (cha != last) {
					return false;
				}
			}
		}
		return size == 0;
	}
```



# [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)(剪枝练习)

#### 保证所有分支尽可能在中间过程判断剪枝,保证递归效率



数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

```java
	public static List<String> generateParenthesis(int n) {
		char[] path = new char[n << 1];
		List<String> ans = new ArrayList<>();
		process(path, 0, 0, n, ans);
		return ans;
	}
	// path 做的决定  path[0....index-1]做完决定的！
	// path[index.....] 还没做决定，当前轮到index位置做决定！
	public static void process(char[] path, int index, int leftMinusRight, int leftRest, List<String> ans) {
		if (index == path.length) {
			ans.add(String.valueOf(path));//剪枝剪得好直接返回字符 不用判断
		} else {
			// index (   )
			if (leftRest > 0) {
				path[index] = '(';
				process(path, index + 1, leftMinusRight + 1, leftRest - 1, ans);
			}
			if (leftMinusRight > 0) {
				path[index] = ')';
				process(path, index + 1, leftMinusRight - 1, leftRest, ans);
			}
		}
	}
```

# [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)(双指针)

```java
public static int removeDuplicates(int[] nums) {
		if (nums == null) {
			return 0;
		}
		if (nums.length < 2) {
			return nums.length;
		}
		int done = 0;
		for (int i = 1; i < nums.length; i++) {
			if (nums[i] != nums[done]) {
				nums[++done] = nums[i];
			}
		}
		return done + 1;
	}
```

# [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)(旋转数组-二分变种-面试向)

有序数组 左右互相交换了一下, 求target的位置.



很多情况下 对有序数组稍微修改过后

依然能使用二分法, 只是控制条件更多, 更复杂一些而已

就是考察你的分析能力, 

```java
// arr，原本是有序数组，旋转过，而且左部分长度不知道
// 找num
// num所在的位置返回
public static int search(int[] arr, int num) {
   int L = 0;
   int R = arr.length - 1;
   int M = 0;
   while (L <= R) {
      // M = L + ((R - L) >> 1)
      M = (L + R) / 2;
      if (arr[M] == num) {
         return M;
      }
      // arr[M] != num
      // [L] == [M] == [R] != num 无法二分
      if (arr[L] == arr[M] && arr[M] == arr[R]) {
         while (L != M && arr[L] == arr[M]) {
            L++;
         }
         // 1) L == M L...M 一路都相等
         // 2) 从L到M终于找到了一个不等的位置
         if (L == M) { // L...M 一路都相等
            L = M + 1;
            continue;
         }
      }
      // ...
      // arr[M] != num
      // [L] [M] [R] 不都一样的情况, 如何二分的逻辑
      if (arr[L] != arr[M]) {
         //如果 2, 3, 4, 5, 7, 1, 1, 1, 1;
         //    L          M            R
         if (arr[M] > arr[L]) { // L...M 一定有序  断点一定在右侧
            if (num >= arr[L] && num < arr[M]) { //  3  [L] == 1    [M]   = 5   L...M - 1
               R = M - 1;
            } else { // 9    [L] == 2    [M]   =  7   M... R
               L = M + 1;
            }
         } else { // [L] > [M]    L....M  存在断点
            if (num > arr[M] && num <= arr[R]) {
               L = M + 1;
            } else {
               R = M - 1;
            }
         }
      } else { /// [L] [M] [R] 不都一样，  [L] === [M] -> [M]!=[R]
         if (arr[M] < arr[R]) {
            if (num > arr[M] && num <= arr[R]) {
               L = M + 1;
            } else {
               R = M - 1;
            }
         } else {
            if (num >= arr[L] && num < arr[M]) {
               R = M - 1;
            } else {
               L = M + 1;
            }
         }
      }
   }
   return -1;
}
```











# [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)(二分法)

一个有序数组中找到

小于等于num的最右的位置

和大于等于一个num最左的位置

```java
	public static int[] searchRange(int[] nums, int target) {
		if (nums == null || nums.length == 0) {
			return new int[] { -1, -1 };
		}
		int L = lessMostRight(nums, target) + 1;
		if (L == nums.length || nums[L] != target) {
			return new int[] { -1, -1 };
		}
		return new int[] { L, lessMostRight(nums, target + 1) };
	}

	public static int lessMostRight(int[] arr, int num) {
		int L = 0;
		int R = arr.length - 1;
		int M = 0;
		int ans = -1;
		while (L <= R) {
			M = L + ((R - L) >> 1);
			if (arr[M] < num) {
				ans = M;
				L = M + 1;
			} else {
				R = M - 1;
			}
		}
		return ans;
	}
```

# [36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）


注意：

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
空白格用 '.' 表示。

![img](https://s2.loli.net/2021/12/23/769uNQrShw8UF4X.png)





如何记录重复与否?

```java
	//定义9行 9列 9桶  i行是否出现数j?
		boolean[][] row = new boolean[9][10];
		boolean[][] col = new boolean[9][10];
		boolean[][] bucket = new boolean[9][10];
```

```java
public static boolean isValidSudoku(char[][] board) {
   boolean[][] row = new boolean[9][10];
   boolean[][] col = new boolean[9][10];
   boolean[][] bucket = new boolean[9][10];
   for (int i = 0; i < 9; i++) {
      for (int j = 0; j < 9; j++) {
         int bid = 3 * (i / 3) + (j / 3);//观察通过行列规律得到桶数
         if (board[i][j] != '.') {
            int num = board[i][j] - '0';
            if (row[i][num] || col[j][num] || bucket[bid][num]) {
               return false;
            }
            row[i][num] = true;
            col[j][num] = true;
            bucket[bid][num] = true;
         }
      }
   }
   return true;
}
```



# [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)(hard-递归)

1. 生成三个信息如下 初始化三个表

```java
public static void solveSudoku(char[][] board) {
		boolean[][] row = new boolean[9][10];
		boolean[][] col = new boolean[9][10];
		boolean[][] bucket = new boolean[9][10];
		initMaps(board, row, col, bucket);
		process(board, 0, 0, row, col, bucket);
}

	public static void initMaps(char[][] board, boolean[][] row, boolean[][] col, boolean[][] bucket) {
		for (int i = 0; i < 9; i++) {
			for (int j = 0; j < 9; j++) {
				int bid = 3 * (i / 3) + (j / 3);
				if (board[i][j] != '.') {
					int num = board[i][j] - '0';
					row[i][num] = true;
					col[j][num] = true;
					bucket[bid][num] = true;
				}
			}
		}
	}
```

2. 一个一个位置玩深度优先遍历

```java
	//  当前来到(i,j)这个位置，如果已经有数字，跳到下一个位置上
	//                      如果没有数字，尝试1~9，不能和row、col、bucket冲突
public static boolean process(char[][] board, int i, int j, boolean[][] row,boolean[][] col, boolean[][] bucket) {
   if (i == 9) {//i到了终止位置
      return true;
   }
   // 当离开(i，j)，应该去哪？(nexti, nextj)
   	int nexti = j != 8 ? i : i + 1;//列数j到了8 行数i++
	int nextj = j != 8 ? j + 1 : 0;//列数j到了8 列数j重置 到了下一行的0
//   	int nexti = j == 8 ? i + 1 : i;//列数j到了8 行数i++
//   	int nextj = j == 8 ? 0 : j + 1;//列数j到了8 列数j重置 到了下一行的0
   if (board[i][j] != '.') {
      return process(board, nexti, nextj, row, col, bucket);
   } else {
      // 可以尝试1~9
      int bid = 3 * (i / 3) + (j / 3);
      for (int num = 1; num <= 9; num++) { // 尝试每一个数字1~9
         if ((!row[i][num]) && (!col[j][num]) && (!bucket[bid][num])) {
            // 可以尝试num
            row[i][num] = true;
            col[j][num] = true;
            bucket[bid][num] = true;
            board[i][j] = (char) (num + '0');
            if (process(board, nexti, nextj, row, col, bucket)) {
               return true;
            }
             //恢复现场
            row[i][num] = false;
            col[j][num] = false;
            bucket[bid][num] = false;
            board[i][j] = '.';
         }
      }
      return false;
   }
}
```



# [38. 外观数列](https://leetcode-cn.com/problems/count-and-say/)(👎)

```java
public static String countAndSay(int n) {
		if (n < 1) {
			return "";
		}
		if (n == 1) {
			return "1";
		}
		char[] last = countAndSay(n - 1).toCharArray();
		StringBuilder ans = new StringBuilder();
		int times = 1;
		for (int i = 1; i < last.length; i++) {
			if (last[i - 1] == last[i]) {
				times++;
			} else {
				ans.append(String.valueOf(times));
				ans.append(String.valueOf(last[i - 1]));
				times = 1;
			}
		}
		ans.append(String.valueOf(times));
		ans.append(String.valueOf(last[last.length - 1]));
		return ans.toString();
	}  vvvfm,
```

# [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)(HashMap的使用方式)

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

- 法1°  排序放入 HashMap

- 法2° int[]记录词频 然后判断

```java
public static List<List<String>> groupAnagrams1(String[] strs) {
   HashMap<String, List<String>> map = new HashMap<String, List<String>>();
   for (String str : strs) {
      int[] record = new int[26];
      for (char cha : str.toCharArray()) {
         record[cha - 'a']++;
      }
      StringBuilder builder = new StringBuilder();
      for (int value : record) {
         builder.append(String.valueOf(value)).append("_");
      }
      String key = builder.toString();
      if (!map.containsKey(key)) {
         map.put(key, new ArrayList<String>());
      }
      map.get(key).add(str);
   }
   List<List<String>> res = new ArrayList<List<String>>();
   for (List<String> list : map.values()) {
      res.add(list);
   }
   return res;
}

public static List<List<String>> groupAnagrams2(String[] strs) {
   HashMap<String, List<String>> map = new HashMap<String, List<String>>();
   for (String str : strs) {
      char[] chs = str.toCharArray();
      Arrays.sort(chs);
      String key = String.valueOf(chs);
      if (!map.containsKey(key)) {
         map.put(key, new ArrayList<String>());
      }
      map.get(key).add(str);
   }
   List<List<String>> res = new ArrayList<List<String>>();
   for (List<String> list : map.values()) {
      res.add(list);
   }
   return res;
}
```

# [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)(快速幂)

- 如果n小于0 则先算正数 然后用1除

- 如果n为Integer.MIN_VALUE  则用Integer.MAX_VALUE算 然后再乘一次底数  然后再用1除

```java
public static int pow(int a, int n) {
   int ans = 1;
   int t = a;
   while (n != 0) {
      if ((n & 1) != 0) {
         ans *= t;
      }
      t *= t;
      n >>= 1;
   }
   return ans;
}

// x的n次方，n可能是负数
public static double myPow(double x, int n) {
   if (n == 0) {
      return 1D;
   }
   int pow = Math.abs(n == Integer.MIN_VALUE ? n + 1 : n);
   double t = x;
   double ans = 1D;
   while (pow != 0) {
      if ((pow & 1) != 0) {
         ans *= t;
      }
      pow >>= 1;
      t = t * t;
   }
   if (n == Integer.MIN_VALUE) {
      ans *= x;
   }
   return n < 0 ? (1D / ans) : ans;
}
```

# [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)(Lambda)

```java
public static int[][] merge(int[][] intervals) {
   if (intervals.length == 0) {
      return new int[0][0];
   }
   Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
   int start = intervals[0][0];
   int end = intervals[0][1];
   int size = 0;
   for (int i = 1; i < intervals.length; i++) {
      if (intervals[i][0] > end) {
         intervals[size][0] = start;
         intervals[size++][1] = end;
         start = intervals[i][0];
         end = intervals[i][1];
      } else {
         end = Math.max(end, intervals[i][1]);
      }
   }
   intervals[size][0] = start;
   intervals[size++][1] = end;
   return Arrays.copyOf(intervals, size);
}
```

# [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)(动态规划-防止溢出)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

- 法1° 动态规划

  ```java
  class Solution {
      public int uniquePaths(int m, int n) {
          int[] cur = new int[n];
          Arrays.fill(cur,1);
          for (int i = 1; i < m;i++){
              for (int j = 1; j < n; j++){
                  cur[j] += cur[j-1] ;
              }
          }
          return cur[n-1];
      }
  }
  ```

- 法2° 数学排列组合 C 

  ```java
  public static int uniquePaths(int m, int n) {
  		int right = n - 1;
  		int all = m + n - 2;
  		//分子分母先列出来
  		long o1 = 1;
  		long o2 = 1;
  		// o1乘进去的个数 一定等于 o2乘进去的个数
  		for (int i = right + 1, j = 1; i <= all; i++, j++) {
  			o1 *= i;
  			o2 *= j;
  			long gcd = gcd(o1, o2);
  			o1 /= gcd;
  			o2 /= gcd;
  		}
  		return (int) o1;
  	}
  	// 调用的时候，请保证初次调用时，m和n都不为0
  	public static long gcd(long m, long n) {
  		return n == 0 ? m : gcd(n, m % n);
  	}
  ```

  

# [66. 加一](https://leetcode-cn.com/problems/plus-one/)(精妙的进位判断-easy)

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

```java
public static int[] plusOne(int[] digits) {
   int n = digits.length;
   for (int i = n - 1; i >= 0; i--) {
       //精妙的进位判断
      if (digits[i] < 9) {
         digits[i]++;
         return digits;
      }
      digits[i] = 0;
   }
   int[] ans = new int[n + 1];
   ans[0] = 1;
   return ans;
}
```



# [69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/)(求平方根-二分法)

```java
// x一定非负，输入可以保证
public static int mySqrt(int x) {
   if (x == 0) {
      return 0;
   }
   if (x < 3) {
      return 1;
   }
   // x >= 3
   long ans = 1;
   long L = 1;
   long R = x;
   long M = 0;
   while (L <= R) {
      M = (L + R) / 2;
      if (M * M <= x) {
         ans = M;
         L = M + 1;
      } else {
         R = M - 1;
      }
   }
   return (int) ans;
}
```

#### 进阶-求小数点后几位

例如求后四位 根号下10

先二分得出整数位

3.0000 ~ 3.9999 之间再二分

就是0000 ~ 9999之间试 

例如试4999

用的就是3.4999*3.4999 与 10 比大小 然后二分



# [73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)

给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**

![image-20211224103429642](https://s2.loli.net/2021/12/24/Pr6dInDQHmN7SWT.png)

```java
/////////////////////////////////////////法1°/////////////////////////////////////////
public static void setZeroes1(int[][] matrix) {
		boolean row0Zero = false;
		boolean col0Zero = false;
		int i = 0;
		int j = 0;
		for (i = 0; i < matrix[0].length; i++) {
			if (matrix[0][i] == 0) {
				row0Zero = true;
				break;
			}
		}
		for (i = 0; i < matrix.length; i++) {
			if (matrix[i][0] == 0) {
				col0Zero = true;
				break;
			}
		}
		for (i = 1; i < matrix.length; i++) {
			for (j = 1; j < matrix[0].length; j++) {
				if (matrix[i][j] == 0) {
					matrix[i][0] = 0;
					matrix[0][j] = 0;
				}
			}
		}
		for (i = 1; i < matrix.length; i++) {
			for (j = 1; j < matrix[0].length; j++) {
				if (matrix[i][0] == 0 || matrix[0][j] == 0) {
					matrix[i][j] = 0;
				}
			}
		}
		if (row0Zero) {
			for (i = 0; i < matrix[0].length; i++) {
				matrix[0][i] = 0;
			}
		}
		if (col0Zero) {
			for (i = 0; i < matrix.length; i++) {
				matrix[i][0] = 0;
			}
		}
	}
/////////////////////////////////////////法2°/////////////////////////////////////////
public static void setZeroes2(int[][] matrix) {
   boolean col0 = false;//第0列是否要变0
   int i = 0;
   int j = 0;
   for (i = 0; i < matrix.length; i++) {
      for (j = 0; j < matrix[0].length; j++) {
         if (matrix[i][j] == 0) {
            matrix[i][0] = 0;
            if (j == 0) {
               col0 = true;
            } else {
               matrix[0][j] = 0;
            }
         }
      }
   }
   for (i = matrix.length - 1; i >= 0; i--) {
      for (j = 1; j < matrix[0].length; j++) {
         if (matrix[i][0] == 0 || matrix[0][j] == 0) {
            matrix[i][j] = 0;
         }
      }
   }
   if (col0) {
      for (i = 0; i < matrix.length; i++) {
         matrix[i][0] = 0;
      }
   }
}
```



# [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

m×n的字母表格中不回头找单词

![img](https://s2.loli.net/2021/12/24/HZn1soIgd8qlMDR.jpg)





# [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)(重要-谁大拷贝谁到尾部)

两个指针向左移动

![image-20211224115156118](https://s2.loli.net/2021/12/24/OwNt23PRThJzv47.png)

```java
public static void merge(int[] nums1, int m, int[] nums2, int n) {
   int index = nums1.length;
   while (m > 0 && n > 0) {
      if (nums1[m - 1] >= nums2[n - 1]) {
         nums1[--index] = nums1[--m];
      } else {
         nums1[--index] = nums2[--n];
      }
   }
   while (m > 0) {
      nums1[--index] = nums1[--m];
   }
   while (n > 0) {
      nums1[--index] = nums2[--n];
   }
}
```

# [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> 1
'B' -> 2
...
'Z' -> 26
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。

#### [639. 解码方法 II](https://leetcode-cn.com/problems/decode-ways-ii/)(分类讨论练习-进阶)

有通配符 * = 1 ~ 9 返回可能种数

# [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)(Morris遍历 不快 但是省空间)

- 普通笔试用递归即可 ==**耗费系统栈空间**==

```java
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public boolean isValidBST(TreeNode node, long lower, long upper) {
        if (node == null) {
            return true;
        }
        if (node.val <= lower || node.val >= upper) {
            return false;
        }
        return isValidBST(node.left, lower, node.val) && isValidBST(node.right, node.val, upper);
    }
```

- 面试可以提及Morris遍历: **==利用叶子节点空闲指针来遍历 省的是系统栈空间==**

```java
    public boolean isValidBST(TreeNode root) {
      if (root == null) {
         return true;
      }
      TreeNode cur = root;
      TreeNode mostRight = null;
      Integer pre = null;
      boolean ans = true;
      while (cur != null) {
         mostRight = cur.left;
         if (mostRight != null) {
            while (mostRight.right != null && mostRight.right != cur) {
               mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
               mostRight.right = cur;
               cur = cur.left;
               continue;
            } else {
               mostRight.right = null;
            }
         }
         if (pre != null && pre >= cur.val) {
            ans = false;
         }
         pre = cur.val;
         cur = cur.right;
      }
      return ans;
   }

}
```



# [101. 判断对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)(递归和迭代两种方法)

- 递归方式 (==优美的递归函数==)

```java
public static class TreeNode {
   int val;
   TreeNode left;
   TreeNode right;
}
public boolean isSymmetric(TreeNode root) {
   return isMirror(root, root);
}
// 一棵树是原始树  head1
// 另一棵是翻面树  head2
public static boolean isMirror(TreeNode head1, TreeNode head2) {
   if (head1 == null && head2 == null) {
      return true;
   }
   if (head1 != null && head2 != null) {
      return head1.val == head2.val 
            && isMirror(head1.left, head2.right) 
            && isMirror(head1.right, head2.left);
   }
   // 一个为空，一个不为空  false
   return false;
}
```

- 迭代方式

???















