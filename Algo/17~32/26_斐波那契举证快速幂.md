# 子数组最小的累加和

给定一个数组arr，

返回所有子数组最小值的累加和



## 解题



同数的解决思路 ! ! !

![image-20211030151434222](https://raw.githubusercontent.com/handsomeyi/Pics/master/image-20211030151434222.png)

**结尾, 到相等的时候停住.**





```java
public static int sumSubarrayMins(int[] arr) {
   int[] stack = new int[arr.length];
   int[] left = nearLessEqualLeft(arr, stack);// 小于
   int[] right = nearLessRight(arr, stack);
   long ans = 0;
   for (int i = 0; i < arr.length; i++) {
      long start = i - left[i];//左边元素数
      long end = right[i] - i;//右边元素数
      ans += start * end * (long) arr[i];//左×右×子数组最最小值
      ans %= 1000000007;
   }
   return (int) ans;
}

public static int[] nearLessEqualLeft(int[] arr, int[] stack) {
   int N = arr.length;
   int[] left = new int[N];
   int size = 0;
   for (int i = N - 1; i >= 0; i--) {
      while (size != 0 && arr[i] <= arr[stack[size - 1]]) {
         left[stack[--size]] = i;
      }
      stack[size++] = i;
   }
   while (size != 0) {
      left[stack[--size]] = -1;
   }
   return left;
}

public static int[] nearLessRight(int[] arr, int[] stack) {
   int N = arr.length;
   int[] right = new int[N];
   int size = 0;
   for (int i = 0; i < N; i++) {
      while (size != 0 && arr[stack[size - 1]] > arr[i]) {
         right[stack[--size]] = i;
      }
      stack[size++] = i;
   }
   while (size != 0) {
      right[stack[--size]] = N;
   }
   return right;
}
```

# 斐波那契矩阵

![image-20211030154903223](https://raw.githubusercontent.com/handsomeyi/Pics/master/image-20211030154903223.png)

## 解题

## 总结

==**解题思想**==

以i位置的数做某一个标准下的答案, 下一个数做某一个标准下的答案, 再下一次做某一个标准下的答案

合起来就是总答案



只要

有固定的递推式, 就会有O(logN)的方法

如下, 线性代数的思想: 

![image-20211030160258783](https://raw.githubusercontent.com/handsomeyi/Pics/master/image-20211030160258783.png)

---

得到通式:

![image-20211030160547388](https://raw.githubusercontent.com/handsomeyi/Pics/master/image-20211030160547388.png)

---

上面这个通式要求一个数的N次方 

求一个数的N次方, 本来要**O(N)** , 优化后的最小代价 是**O(logN)** 

![image-20211030162105257](https://raw.githubusercontent.com/handsomeyi/Pics/master/image-20211030162105257.png)

---

单位矩阵的概念

![image-20211030162953474](https://raw.githubusercontent.com/handsomeyi/Pics/master/image-20211030162953474.png)

---

例子:

![image-20211030164803528](https://raw.githubusercontent.com/handsomeyi/Pics/master/image-20211030164803528.png)



# 母牛生崽

第一年农场有1只成熟的母牛A，往后的每年：

1）每一只成熟的母牛都会生一只母牛

2）每一只新出生的母牛都在出生的第三年成熟

3）每一只母牛永远不会死

返回N年后牛的数量

## 解题

列数字发现: **F(n) = F(n-1) + F(n-3)**



F4, F3, F2

![image-20211030165715830](https://raw.githubusercontent.com/handsomeyi/Pics/master/image-20211030165715830.png)

---



F3, F4, F5 再分析 F4, F5, F6 得到的 多项式, 可以解出abcdefghi

![image-20211030165949784](https://raw.githubusercontent.com/handsomeyi/Pics/master/image-20211030165949784.png)





# 返回达标字符串

给定一个数N，想象只由0和1两种字符，组成的所有长度为N的字符串

如果某个字符串,任何0字符的左边都有1紧挨着,

认为这个字符串达标

返回有多少达标的字符串

## 解题

**观察发现**: 

N=1	1个达标

N=2	2个达标

N=3	3个达标

N=4	5个达标

N=5	8个达标

N=6	13个达标



并且: 还有一个观察的过程, 就是太抽象了!

![image-20211030172015800](https://raw.githubusercontent.com/handsomeyi/Pics/master/image-20211030172015800.png)

F(i)就是还剩第一个数为1, 还剩i个数要去决定





如果第二个数选1, 接下来的选择就等价于 F(i-1)

如果第二个数选0, 接下来的选择就等价于 F(i-2)---------( 因为选了0, 第三个数必然为1, 所以就是F(i-2) )



# 总结

(**不能有条件转移, 即不能有if选择状态这种事情** 发生)

斐波那契数列问题思考思路: 向状态转移上靠 ! 

![image-20211030173509786](https://raw.githubusercontent.com/handsomeyi/Pics/master/image-20211030173509786.png)







































