# 如何预防死锁？(互不请循环)

1. **互斥条件** 同一时间只能有一个线程获取资源。 

2. **不可剥夺条件** 一个线程已经占有的资源，在释放之前不会被其它线程抢占 
3. **请求和保持条件** 线程等待过程中不会释放已占有的资源 
4. **循环等待条件** 多个线程互相等待对方释放资源

# 多线程有哪几种创建方式？

 实现Runnable => 是run()，无返回值，无法抛出异常

. 实现Callable => 是call()，任务执行后有返回值，可以抛出异常

. 继承Thread类创建多线程：=> 重写Thread类的run()方法 调用start()方法开启线程。

通过线程池创建线程.

Future 里面的FutureTask可以创建

# 描述一下线程安全活跃态问题，竞态条件？

 线程安全的活跃性问题可以分为 死锁、活锁、饥饿

死锁

线程在对同一把锁进行竞争的时候，未抢占到锁的线程会等待持有锁的线程释放锁 后继续抢占，如果两个或两个以上的线程互相持有对方将要抢占的锁，互相等待对方先 行释放锁就会进入到一个循环等待的过程，这个过程就叫做死锁

活锁

活锁 就是有时线程虽然没有发生阻塞，但是仍然会存在执行不下去的情况，活锁不会阻 塞线程，线程会一直重复执行某个相同的操作，并且一直失败重

 饥饿

 就是 线程因无法访问所需资源而无法执行下去的情况，

饥饿 分为两种情况：

1. 一种是**其他的线程在临界区做了无限循环或无限制等待资源**的操作，让其他的 线程一直不能拿到锁进入临界区，对其他线程来说，就进入了饥饿状态 

2. 另一种是因为**线程优先级不合理的分配**，导致部分线程始终无法获取到CPU资 源而一直无法执行

解决饥饿的问题有几种方案

1. 保证资源充足，很多场景下，资源的稀缺性无法解决 
2. **==公平分配==**资源，在并发编程里使用公平锁，例如FIFO策略，线程等待是有顺 序的，排在等待队列前面的线程会优先获得资源 
3. 避免持有锁的线程长时间执行，很多场景下，持有锁的线程的执行时间也很难 缩短

# Java中的wait和sleep的区别与联系？

sleep => 针对线程, 就是线程里面的方法

wait => syn里面上syn锁, 是对象头相关, 肯定就是对象里面的属性, 也就是Object类里

其次一个与锁有关, 一个与锁无关.

两者均可被中断唤醒.

# 描述一下进程与线程区别？

- 进程

  是系统进行**资源分配和调度**的基本单位 => 系统中运行的程序(代码 各种数据结构 ...)

  ==资源分配==的最小单位.

- 线程

  是CPU的**运算调度**最小单位, 包含在进程之中, 是进程的实际运行单位. 

  一个进程可以并发执行多个线程 => 并发: 系统给到线程的时间片轮转

  ==程序执行==的最小单位.

进程是活的程序 => 线程和进程没什么区别 => 两者控制块都是同一个 都是task struct

如何模拟线程 => 线程要共享资源共享空间 => 也就是另外一个进程共享资源后 => 就都变成了线程

![image-20220321133615952](https://s2.loli.net/2022/03/21/GftFlgsb81DW4ec.png)

fork => 创建新进程 => 对应的新进程分配的内存是一块新空间

clone => 创建新线程 => 对应分配的内存是和 原进程相同的空间 共享了, 实际上他也就是跑起来的一个程序, 只是和原来的共享了, 达到了双倍吞吐量的效果.

# 描述一下Java线程的生命周期?

新建 => 就绪 => 运行 => 阻塞 => 销毁

按JDK的源码分析来看，Thread的状态分为：

![image-20220321134546683](https://s2.loli.net/2022/03/21/unWy6H2fsELVazD.png)

new  => 新生

Runnable => 调用start的时候才绑定原生操作系统的线程, 现在就是就绪了

得到时间片运行线程 => Running

Running => 调用sleep/wait => Blocked阻塞

Running => 跑完Terminal 销毁

# 开多少线程? => 业务强相关

计算密集 => 上下文切换开销成为瓶颈 => 减少上下文切换 => 越密集,越接近CPU核心数

IO密集   =>  两倍CPU往上加, 压测来看, 再看吞吐量和时延 => 进行一个取舍