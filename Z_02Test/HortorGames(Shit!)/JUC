# 如何预防死锁？(互不请循)

1. **互斥条件** 同一时间只能有一个线程获取资源。 

2. **不可剥夺条件** 一个线程已经占有的资源，在释放之前不会被其它线程抢占 
3. **请求和保持条件** 线程等待过程中不会释放已占有的资源 
4. **循环等待条件** 多个线程互相等待对方释放资源

# 多线程有哪几种创建方式？

 实现Runnable => 是run()，无返回值，无法抛出异常

. 实现Callable => 是call()，任务执行后有返回值，可以抛出异常

. 继承Thread类创建多线程：=> 重写Thread类的run()方法 调用start()方法开启线程。

通过线程池创建线程.

Future 里面的FutureTask可以创建

# 描述一下线程安全活跃态问题，竞态条件？

 线程安全的活跃性问题可以分为 死锁、活锁、饥饿

死锁

线程在对同一把锁进行竞争的时候，未抢占到锁的线程会等待持有锁的线程释放锁 后继续抢占，如果两个或两个以上的线程互相持有对方将要抢占的锁，互相等待对方先 行释放锁就会进入到一个循环等待的过程，这个过程就叫做死锁

活锁

活锁 就是有时线程虽然没有发生阻塞，但是仍然会存在执行不下去的情况，活锁不会阻 塞线程，线程会一直重复执行某个相同的操作，并且一直失败重

 饥饿

 就是 线程因无法访问所需资源而无法执行下去的情况，

饥饿 分为两种情况：

1. 一种是**其他的线程在临界区做了无限循环或无限制等待资源**的操作，让其他的 线程一直不能拿到锁进入临界区，对其他线程来说，就进入了饥饿状态 

2. 另一种是因为**线程优先级不合理的分配**，导致部分线程始终无法获取到CPU资 源而一直无法执行

解决饥饿的问题有几种方案

1. 保证资源充足，很多场景下，资源的稀缺性无法解决 
2. **==公平分配==**资源，在并发编程里使用公平锁，例如FIFO策略，线程等待是有顺 序的，排在等待队列前面的线程会优先获得资源 
3. 避免持有锁的线程长时间执行，很多场景下，持有锁的线程的执行时间也很难 缩短

# Java中的wait和sleep的区别与联系？

sleep => 针对线程, 就是线程里面的方法

wait => syn里面上syn锁, 是对象头相关, 肯定就是对象里面的属性, 也就是Object类里

其次一个与锁有关, 一个与锁无关.

两者均可被中断唤醒.

# 描述一下进程与线程区别？

- 进程

  是系统进行**资源分配和调度**的基本单位 => 系统中运行的程序(代码 各种数据结构 ...)

  ==资源分配==的最小单位.

- 线程

  是CPU的**运算调度**最小单位, 包含在进程之中, 是进程的实际运行单位. 

  一个进程可以并发执行多个线程 => 并发: 系统给到线程的时间片轮转

  ==程序执行==的最小单位.

进程是活的程序 => 线程和进程没什么区别 => 两者控制块都是同一个 都是task struct

如何模拟线程 => 线程要共享资源共享空间 => 也就是另外一个进程共享资源后 => 就都变成了线程

![image-20220321133615952](https://s2.loli.net/2022/03/21/GftFlgsb81DW4ec.png)

fork => 创建新进程 => 对应的新进程分配的内存是一块新空间

clone => 创建新线程 => 对应分配的内存是和 原进程相同的空间 共享了, 实际上他也就是跑起来的一个程序, 只是和原来的共享了, 达到了双倍吞吐量的效果.



# 描述一下Java线程的生命周期?

新建 => 就绪 => 运行 => 阻塞 => 销毁

按JDK的源码分析来看，Thread的状态分为：

![image-20220321134546683](https://s2.loli.net/2022/03/21/unWy6H2fsELVazD.png)

new  => 新生

Runnable => 调用start的时候才绑定原生操作系统的线程, 现在就是就绪了

得到时间片运行线程 => Running

Running => 调用sleep/wait => Blocked阻塞

Running => 跑完Terminal 销毁

# 开多少线程? => 业务强相关

计算密集 => 上下文切换开销成为瓶颈 => 减少上下文切换 => 越密集,越接近CPU核心数

IO密集   =>  两倍CPU往上加, 压测来看, 再看吞吐量和时延 => 进行一个取舍





# 进程间通信

**标准回答**

进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket：

1. **管道**

   管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区，Linux 系统中通过 pipe() 函数创建管道，会生成两个文件描述符，分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。

2. **命名管道**

   匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。

3. **信号**

   信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。

4. **消息队列**

   消息队列就是一个消息的链表，可以把消息看作一个记录，具有特定的格式以及特定的优先级，对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程则可以从消息队列中读走消息，消息队列是随内核持续的。

5. **共享内存**

   共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。

6. **内存映射**

   内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。

7. **信号量**(PV操作)

   信号量主要用来解决进程和线程间并发执行时的同步问题，进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为 P 操作和 V 操作，P 操作是将信号量的值减 1，V 操作是将信号量的值加 1。当信号量的值小于等于 0 之后，再进行 P 操作时，当前进程或线程会被阻塞，直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时。

8. Socket

   套接字（Socket），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。Socket 一般用于网络中**不同主机上的进程之间**的通信。

# 线程间同步(通信)

**互斥量(Mutex)**: 互斥对象机制, 拥有互斥对象才能访问.

**信号量**: 允许同一时刻多个线程访问一个资格, 但是需要控制同时访问资源的最大线程数.

**事件(Event)**: 通过通知方式实现同步(wait, notify)